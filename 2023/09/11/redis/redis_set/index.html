<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"nytech3.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="工作流程 解析命令参数，检查命令的拓展参数是否有冲突或者其他异常 对set命令的值进行合适的编码，以减少对内存空间的浪费 如果包含GET参数，则查找旧值，并将旧值加入server.pending_push_messages中等待发送 在查找数据时，如果服务正在进行rehash操作，则执行一步rehash操作 查找对应的key，更新lru&#x2F;lfu时间, 并进行命中记录(getGenericComm">
<meta property="og:type" content="article">
<meta property="og:title" content="源码阅读(二)-Redis中的SET命令">
<meta property="og:url" content="https://nytech3.github.io/2023/09/11/redis/redis_set/index.html">
<meta property="og:site_name" content="nytech">
<meta property="og:description" content="工作流程 解析命令参数，检查命令的拓展参数是否有冲突或者其他异常 对set命令的值进行合适的编码，以减少对内存空间的浪费 如果包含GET参数，则查找旧值，并将旧值加入server.pending_push_messages中等待发送 在查找数据时，如果服务正在进行rehash操作，则执行一步rehash操作 查找对应的key，更新lru&#x2F;lfu时间, 并进行命中记录(getGenericComm">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-09-11T10:00:00.000Z">
<meta property="article:modified_time" content="2024-09-19T07:25:57.001Z">
<meta property="article:author" content="nytech">
<meta property="article:tag" content="c">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://nytech3.github.io/2023/09/11/redis/redis_set/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>源码阅读(二)-Redis中的SET命令 | nytech</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">nytech</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">24</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">3</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">140</span></a>

  </li>
        <li class="menu-item menu-item-following">

    <a href="/following/" rel="section"><i class="following fa-fw"></i>关注</a>

  </li>
        <li class="menu-item menu-item-tool">

    <a href="/tool/" rel="section"><i class="tool fa-fw"></i>工具</a>

  </li>
        <li class="menu-item menu-item-dailyguide">

    <a href="/dailyguide" rel="section"><i class="dailyguide fa-fw"></i>每日导读</a>

  </li>
        <li class="menu-item menu-item-book">

    <a href="/book" rel="section"><i class="book fa-fw"></i>书籍</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/nytech3" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nytech3.github.io/2023/09/11/redis/redis_set/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/author.jpg">
      <meta itemprop="name" content="nytech">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nytech">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          源码阅读(二)-Redis中的SET命令
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-11 18:00:00" itemprop="dateCreated datePublished" datetime="2023-09-11T18:00:00+08:00">2023-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/" itemprop="url" rel="index"><span itemprop="name">technology</span></a>
                </span>
            </span>

          
            <span id="/2023/09/11/redis/redis_set/" class="post-meta-item leancloud_visitors" data-flag-title="源码阅读(二)-Redis中的SET命令" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <!-- ttoc -->
<h1 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h1><ol>
<li>解析命令参数，检查命令的拓展参数是否有冲突或者其他异常</li>
<li>对set命令的值进行合适的编码，以减少对内存空间的浪费</li>
<li>如果包含GET参数，则查找旧值，并将旧值加入server.pending_push_messages中等待发送</li>
<li>在查找数据时，如果服务正在进行rehash操作，则执行一步rehash操作</li>
<li>查找对应的key，更新lru/lfu时间, 并进行命中记录(getGenericCommandh会记录，lookupKeyWrite不会记录)</li>
<li>对NX与XX是否能设置值进行判断，如果不能则将NULL加入reply队列中</li>
<li>调用setkey,将键值对加入字典中</li>
<li>如果有过期操作的话，对key进行过期(主服务器才会删除对应的键值对，从服务器只会返回已过期，但不会删除键值对)，并执行重写命令操作和发送键过期的事件通知</li>
</ol>
<span id="more"></span>




<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="Set-json"><a href="#Set-json" class="headerlink" title="Set json"></a>Set json</h2><p>设置一个字符串类型的键值对。时间复杂度为O(1), 该命令是从1.0.0版本开始引进，其至少接收三个参数以上，对应使用的函数为<code>setCommand</code>(可以在<code>t_string.c</code>中查看)<br>set的配置文件<code>set.json</code>,内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;SET&quot;: &#123;</span><br><span class="line">        &quot;summary&quot;: &quot;Sets the string value of a key, ignoring its type. The key is created if it doesn&#39;t exist.&quot;, # 对于set命令的描述</span><br><span class="line">        &quot;complexity&quot;: &quot;O(1)&quot;, # 时间复杂度</span><br><span class="line">        &quot;group&quot;: &quot;string&quot;, # 分组为string</span><br><span class="line">        &quot;since&quot;: &quot;1.0.0&quot;, # 引入该命令的版本</span><br><span class="line">        &quot;arity&quot;: -3, # 命令的参数数量，这里的-3表示至少包含3个参数。</span><br><span class="line">        &quot;function&quot;: &quot;setCommand&quot;, # 实现该命令的函数名称。</span><br><span class="line">        &quot;get_keys_function&quot;: &quot;setGetKeys&quot;, # 获取命令中所有键的函数名称。</span><br><span class="line">        &quot;history&quot;: [ # 命令的历史版本信息，包括版本号和在该版本中对命令进行的更改。</span><br><span class="line">            [</span><br><span class="line">                &quot;2.6.12&quot;,</span><br><span class="line">                &quot;Added the &#96;EX&#96;, &#96;PX&#96;, &#96;NX&#96; and &#96;XX&#96; options.&quot;</span><br><span class="line">            ],</span><br><span class="line">            [</span><br><span class="line">                &quot;6.0.0&quot;,</span><br><span class="line">                &quot;Added the &#96;KEEPTTL&#96; option.&quot;</span><br><span class="line">            ],</span><br><span class="line">            [</span><br><span class="line">                &quot;6.2.0&quot;,</span><br><span class="line">                &quot;Added the &#96;GET&#96;, &#96;EXAT&#96; and &#96;PXAT&#96; option.&quot;</span><br><span class="line">            ],</span><br><span class="line">            [</span><br><span class="line">                &quot;7.0.0&quot;,</span><br><span class="line">                &quot;Allowed the &#96;NX&#96; and &#96;GET&#96; options to be used together.&quot;</span><br><span class="line">            ]</span><br><span class="line">        ],</span><br><span class="line">        &quot;command_flags&quot;: [ # 命令的标志，描述命令的一些特性。例如，&quot;WRITE&quot;表示这是一个写命令，&quot;DENYOOM&quot;表示在内存不足时拒绝执行该命令。</span><br><span class="line">            &quot;WRITE&quot;,</span><br><span class="line">            &quot;DENYOOM&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;acl_categories&quot;: [ # 命令的访问控制列表（ACL）类别。</span><br><span class="line">            &quot;STRING&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;key_specs&quot;: [ # 命令中键的规格。</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;notes&quot;: &quot;RW and ACCESS due to the optional &#96;GET&#96; argument&quot;,</span><br><span class="line">                &quot;flags&quot;: [</span><br><span class="line">                    &quot;RW&quot;,</span><br><span class="line">                    &quot;ACCESS&quot;,</span><br><span class="line">                    &quot;UPDATE&quot;,</span><br><span class="line">                    &quot;VARIABLE_FLAGS&quot;</span><br><span class="line">                ],</span><br><span class="line">                &quot;begin_search&quot;: &#123;</span><br><span class="line">                    &quot;index&quot;: &#123;</span><br><span class="line">                        &quot;pos&quot;: 1</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;find_keys&quot;: &#123;</span><br><span class="line">                    &quot;range&quot;: &#123;</span><br><span class="line">                        &quot;lastkey&quot;: 0,</span><br><span class="line">                        &quot;step&quot;: 1,</span><br><span class="line">                        &quot;limit&quot;: 0</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;reply_schema&quot;: &#123; # 命令的返回值类型和描述。</span><br><span class="line">            &quot;anyOf&quot;:[</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;description&quot;: &quot;&#96;GET&#96; not given: Operation was aborted (conflict with one of the &#96;XX&#96;&#x2F;&#96;NX&#96; options).&quot;,</span><br><span class="line">                    &quot;type&quot;: &quot;null&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;description&quot;: &quot;&#96;GET&#96; not given: The key was set.&quot;,</span><br><span class="line">                    &quot;const&quot;: &quot;OK&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;description&quot;: &quot;&#96;GET&#96; given: The key didn&#39;t exist before the &#96;SET&#96;&quot;,</span><br><span class="line">                    &quot;type&quot;: &quot;null&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;description&quot;: &quot;&#96;GET&#96; given: The previous value of the key&quot;,</span><br><span class="line">                    &quot;type&quot;: &quot;string&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;arguments&quot;: [ # 命令的参数列表，包括参数的名称，类型，是否是可选的，什么版本开始支持等信息。</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;key&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;key&quot;,</span><br><span class="line">                &quot;key_spec_index&quot;: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;value&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;string&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;condition&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;oneof&quot;,</span><br><span class="line">                &quot;optional&quot;: true,</span><br><span class="line">                &quot;since&quot;: &quot;2.6.12&quot;,</span><br><span class="line">                &quot;arguments&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;name&quot;: &quot;nx&quot;,</span><br><span class="line">                        &quot;type&quot;: &quot;pure-token&quot;,</span><br><span class="line">                        &quot;token&quot;: &quot;NX&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;name&quot;: &quot;xx&quot;,</span><br><span class="line">                        &quot;type&quot;: &quot;pure-token&quot;,</span><br><span class="line">                        &quot;token&quot;: &quot;XX&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;get&quot;,</span><br><span class="line">                &quot;token&quot;: &quot;GET&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;pure-token&quot;,</span><br><span class="line">                &quot;optional&quot;: true,</span><br><span class="line">                &quot;since&quot;: &quot;6.2.0&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;: &quot;expiration&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;oneof&quot;,</span><br><span class="line">                &quot;optional&quot;: true,</span><br><span class="line">                &quot;arguments&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;name&quot;: &quot;seconds&quot;,</span><br><span class="line">                        &quot;type&quot;: &quot;integer&quot;,</span><br><span class="line">                        &quot;token&quot;: &quot;EX&quot;,</span><br><span class="line">                        &quot;since&quot;: &quot;2.6.12&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;name&quot;: &quot;milliseconds&quot;,</span><br><span class="line">                        &quot;type&quot;: &quot;integer&quot;,</span><br><span class="line">                        &quot;token&quot;: &quot;PX&quot;,</span><br><span class="line">                        &quot;since&quot;: &quot;2.6.12&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;name&quot;: &quot;unix-time-seconds&quot;,</span><br><span class="line">                        &quot;type&quot;: &quot;unix-time&quot;,</span><br><span class="line">                        &quot;token&quot;: &quot;EXAT&quot;,</span><br><span class="line">                        &quot;since&quot;: &quot;6.2.0&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;name&quot;: &quot;unix-time-milliseconds&quot;,</span><br><span class="line">                        &quot;type&quot;: &quot;unix-time&quot;,</span><br><span class="line">                        &quot;token&quot;: &quot;PXAT&quot;,</span><br><span class="line">                        &quot;since&quot;: &quot;6.2.0&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;name&quot;: &quot;keepttl&quot;,</span><br><span class="line">                        &quot;type&quot;: &quot;pure-token&quot;,</span><br><span class="line">                        &quot;token&quot;: &quot;KEEPTTL&quot;,</span><br><span class="line">                        &quot;since&quot;: &quot;6.0.0&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="分组-group"><a href="#分组-group" class="headerlink" title="分组(group)"></a>分组(group)</h3><p>Redis命令分组主要是为了将具有相似功能或操作相同数据类型的命令归类在一起，方便用户查找和理解命令。<br>例如，所有操作字符串（String）类型数据的命令都被归类在”string”组中，如 SET, GET, APPEND等；所有操作列表（List）类型数据的命令都被归类在”list”组中，如 LPUSH, LPOP等。<br>命令分组的主要作用包括：</p>
<ol>
<li>方便查找：通过命令分组，用户可以更方便地查找到他们需要的命令。例如，如果用户想查找所有和字符串操作相关的命令，他只需要查找”string”分组下的命令即可。</li>
<li>方便理解：通过命令分组，用户可以更好地理解命令的功能和用法。例如，通过查看”string”分组下的命令，用户可以更好地理解Redis如何操作字符串。</li>
<li>方便维护：对于Redis的开发者来说，命令分组可以方便他们维护和更新命令。例如，如果开发者想要添加一个新的操作字符串的命令，他只需要将这个命令添加到”string”分组即可。</li>
</ol>
<h3 id="获取key函数-get-keys-function"><a href="#获取key函数-get-keys-function" class="headerlink" title="获取key函数(get_keys_function)"></a>获取key函数(get_keys_function)</h3><p>当Redis服务器接收到一个命令时，它会使用get_keys_function来确定这个命令会影响哪些键。这对于很多Redis的内部操作是非常重要的，例如在执行命令前检查键的数据类型，或在集群模式下将命令路由到正确的节点。<br>每个Redis命令都有一个相关的get_keys_function。例如，对于SET命令，get_keys_function可能会提取出命令的第一个参数作为键。而对于HSET命令，get_keys_function可能会提取出命令的第一个和第三个参数作为键。   </p>
<h3 id="权限分类-acl-categories"><a href="#权限分类-acl-categories" class="headerlink" title="权限分类(acl_categories)"></a>权限分类(acl_categories)</h3><p>在Redis的ACL（Access Control Lists）系统中，acl_categories是一个命令属性，表示该命令属于哪一类别。这些类别帮助管理员以组的方式管理和控制对命令的访问权限。<br>string在acl_categories中表示这个命令属于处理String类型数据的命令集合。例如，SET、GET、APPEND等命令都属于string类别。<br>当管理员设定用户权限时，可以使用这些类别快速地允许或禁止用户执行一组相关的命令。例如，如果管理员想禁止一个用户执行所有处理String类型数据的命令，可以使用以下指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACL SETUSER user -@string</span><br></pre></td></tr></table></figure>
<p>在这个指令中，-@string表示禁止用户执行string类别中的所有命令。<br>总的来说，string在acl_categories中表示这个命令是用于操作String类型数据的，它让Redis的权限管理更加高效和灵活。</p>
<p>以下是一些常见的ACL类别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@keyspace：涵盖所有直接或间接访问键空间的命令，例如GET, SET, DEL等。</span><br><span class="line">@read：涵盖所有读取数据的命令，例如GET, HGETALL等。</span><br><span class="line">@write：涵盖所有修改数据的命令，例如SET, HSET等。</span><br><span class="line">@admin：涵盖所有具有管理功能的命令，例如CONFIG, BGSAVE等。</span><br><span class="line">@dangerous：涵盖所有可能危害Redis正常运行的命令，例如FLUSHDB, KEYS等。</span><br><span class="line">@connection：涵盖所有管理客户端连接的命令，例如AUTH, SELECT, CLIENT等。</span><br><span class="line">@fast：涵盖所有执行时间短，通常在1毫秒内完成的命令，例如SISMEMBER, LLEN等。</span><br><span class="line">@slow：涵盖所有可能执行时间较长的命令，例如KEYS, SMEMBERS等。</span><br><span class="line">@string：涵盖所有操作字符串类型数据的命令，例如GET, SET等。</span><br><span class="line">@list：涵盖所有操作列表类型数据的命令，例如LPOP, RPUSH等。</span><br><span class="line">@set：涵盖所有操作集合类型数据的命令，例如SADD, SREM等。</span><br><span class="line">@sortedset：涵盖所有操作有序集合类型数据的命令，例如ZADD, ZRANGE等。</span><br><span class="line">@hash：涵盖所有操作哈希类型数据的命令，例如HGET, HSET等。</span><br><span class="line">@pubsub：涵盖所有发布订阅相关的命令，例如PUBLISH, SUBSCRIBE等。</span><br><span class="line">@scripting：涵盖所有脚本相关的命令，例如EVAL, SCRIPT等。</span><br><span class="line">@hyperloglog：涵盖所有操作HyperLogLog类型数据的命令，例如PFADD, PFCOUNT等。</span><br><span class="line">@geo：涵盖所有地理位置相关的命令，例如GEOADD, GEORADIUS等。</span><br><span class="line">@stream：涵盖所有操作流数据类型的命令，例如XADD, XRANGE等。</span><br></pre></td></tr></table></figure>
<p>请注意，每个命令可以属于多个类别，例如SET命令就属于@write和@string两个类别。</p>
<h3 id="key-specs"><a href="#key-specs" class="headerlink" title="key_specs"></a>key_specs</h3><p>key_specs是一个命令属性，它定义了如何从命令的参数中找到键。</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>-&gt; setCommand :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SET key value [NX] [XX] [KEEPTTL] [GET] [EX &lt;seconds&gt;] [PX &lt;milliseconds&gt;]</span></span><br><span class="line"><span class="comment"> *     [EXAT &lt;seconds-timestamp&gt;][PXAT &lt;milliseconds-timestamp&gt;] */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 用于存储过期时间 */</span></span><br><span class="line">    robj *expire = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* 默认的单位时间是秒 */</span></span><br><span class="line">    <span class="keyword">int</span> unit = UNIT_SECONDS;</span><br><span class="line">    <span class="comment">/* use flag to mark command opts, one bit represents one type. */</span></span><br><span class="line">    <span class="comment">/* flags用于标记命令选项，每一位代表一种类型，初始值为无标记, 类型如下:</span></span><br><span class="line"><span class="comment">     *   #define OBJ_NO_FLAGS 0</span></span><br><span class="line"><span class="comment">     *   #define OBJ_SET_NX (1&lt;&lt;0)          /* Set if key not exists. */</span></span><br><span class="line">     *   <span class="meta">#<span class="meta-keyword">define</span> OBJ_SET_XX (1&lt;&lt;1)          <span class="comment">/* Set if key exists. */</span></span></span><br><span class="line">     *   <span class="meta">#<span class="meta-keyword">define</span> OBJ_EX (1&lt;&lt;2)              <span class="comment">/* Set if time in seconds is given */</span></span></span><br><span class="line">     *   <span class="meta">#<span class="meta-keyword">define</span> OBJ_PX (1&lt;&lt;3)              <span class="comment">/* Set if time in ms in given */</span></span></span><br><span class="line">     *   <span class="meta">#<span class="meta-keyword">define</span> OBJ_KEEPTTL (1&lt;&lt;4)         <span class="comment">/* Set and keep the ttl */</span></span></span><br><span class="line">     *   <span class="meta">#<span class="meta-keyword">define</span> OBJ_SET_GET (1&lt;&lt;5)         <span class="comment">/* Set if want to get key before set */</span></span></span><br><span class="line">     *   <span class="meta">#<span class="meta-keyword">define</span> OBJ_EXAT (1&lt;&lt;6)            <span class="comment">/* Set if timestamp in second is given */</span></span></span><br><span class="line">     *   <span class="meta">#<span class="meta-keyword">define</span> OBJ_PXAT (1&lt;&lt;7)            <span class="comment">/* Set if timestamp in ms is given */</span></span></span><br><span class="line">     *   <span class="meta">#<span class="meta-keyword">define</span> OBJ_PERSIST (1&lt;&lt;8)         <span class="comment">/* Set if we need to remove the ttl */</span></span></span><br><span class="line">     */</span><br><span class="line">    <span class="keyword">int</span> flags = OBJ_NO_FLAGS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析命令的参数，如果解析失败则直接返回 */</span></span><br><span class="line">    <span class="comment">/* 该函数会修改flags、unit和expire的值 */</span></span><br><span class="line">    <span class="keyword">if</span> (parseExtendedStringArgumentsOrReply(c,&amp;flags,&amp;unit,&amp;expire,COMMAND_SET) != C_OK) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 尝试对键的值进行编码，以节省内存 */</span></span><br><span class="line">    <span class="comment">/* 这个函数会检查值的类型和大小，如果可能的话，会将值编码为一个更小的内部表示(EmbeddedStringObject) */</span></span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">/* 调用setGenericCommand函数执行实际的SET操作 */</span></span><br><span class="line">    <span class="comment">/* 这个函数会根据flags的值决定是否设置过期时间、是否只在键存在时设置值等 */</span></span><br><span class="line">    setGenericCommand(c,flags,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>],expire,unit,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-&gt; setCommand -&gt; parseExtendedStringArgumentsOrReply :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * The parseExtendedStringArgumentsOrReply() function performs the common validation for extended</span></span><br><span class="line"><span class="comment">  * string arguments used in SET and GET command.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * Get specific commands - PERSIST/DEL</span></span><br><span class="line"><span class="comment">  * Set specific commands - XX/NX/GET</span></span><br><span class="line"><span class="comment">  * Common commands - EX/EXAT/PX/PXAT/KEEPTTL</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * Function takes pointers to client, flags, unit, pointer to pointer of expire obj if needed</span></span><br><span class="line"><span class="comment">  * to be determined and command_type which can be COMMAND_GET or COMMAND_SET.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * If there are any syntax violations C_ERR is returned else C_OK is returned.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * Input flags are updated upon parsing the arguments. Unit and expire are updated if there are any</span></span><br><span class="line"><span class="comment">  * EX/EXAT/PX/PXAT arguments. Unit is updated to millisecond if PX/PXAT is set.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment">  * 解析SET和GET命令的扩展字符串参数，如果有语法错误则返回C_ERR，否则返回C_OK。</span></span><br><span class="line"><span class="comment">  * 参数包括：</span></span><br><span class="line"><span class="comment">  * - c：客户端对象，包含了所有的命令参数。</span></span><br><span class="line"><span class="comment">  * - flags：指向一个整数的指针，用于存储解析出的标志位。</span></span><br><span class="line"><span class="comment">  * - unit：指向一个整数的指针，用于存储时间单位（秒或毫秒）。</span></span><br><span class="line"><span class="comment">  * - expire：指向一个对象指针的指针，如果有EX、EXAT、PX或PXAT参数，这个指针会被设置为指向过期时间的对象。</span></span><br><span class="line"><span class="comment">  * - command_type：命令类型，可以是COMMAND_GET或COMMAND_SET。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parseExtendedStringArgumentsOrReply</span><span class="params">(client *c, <span class="keyword">int</span> *flags, <span class="keyword">int</span> *unit, robj **expire, <span class="keyword">int</span> command_type)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据命令类型确定开始解析的扩展参数位置 */</span></span><br><span class="line"><span class="keyword">int</span> j = command_type == COMMAND_GET ? <span class="number">2</span> : <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">    <span class="comment">/* 获取当前参数的字符指针 */</span></span><br><span class="line">    <span class="keyword">char</span> *opt = c-&gt;argv[j]-&gt;ptr;</span><br><span class="line">    robj *next = (j == c-&gt;argc<span class="number">-1</span>) ? <span class="literal">NULL</span> : c-&gt;argv[j+<span class="number">1</span>];</span><br><span class="line">     <span class="keyword">if</span> ((opt[<span class="number">0</span>] == <span class="string">&#x27;n&#x27;</span> || opt[<span class="number">0</span>] == <span class="string">&#x27;N&#x27;</span>) &amp;&amp;</span><br><span class="line">         (opt[<span class="number">1</span>] == <span class="string">&#x27;x&#x27;</span> || opt[<span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>) &amp;&amp; opt[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span> &amp;&amp;</span><br><span class="line">         !(*flags &amp; OBJ_SET_XX) &amp;&amp; (command_type == COMMAND_SET))</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// NX(不存在则进插入键值) 与 XX(存在则插入键值) 不能同时存在，如果同时存在会进入else分支报错</span></span><br><span class="line">         <span class="comment">// 将flag的NX位设置为1 #define OBJ_SET_NX (1&lt;&lt;0) -&gt;  Set if key not exists. </span></span><br><span class="line">         *flags |= OBJ_SET_NX; </span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((opt[<span class="number">0</span>] == <span class="string">&#x27;x&#x27;</span> || opt[<span class="number">0</span>] == <span class="string">&#x27;X&#x27;</span>) &amp;&amp;</span><br><span class="line">                (opt[<span class="number">1</span>] == <span class="string">&#x27;x&#x27;</span> || opt[<span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>) &amp;&amp; opt[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span> &amp;&amp;</span><br><span class="line">                !(*flags &amp; OBJ_SET_NX) &amp;&amp; (command_type == COMMAND_SET))</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="comment">// 将flag的XX位设置为1 #define OBJ_SET_XX (1&lt;&lt;1)    -&gt;    Set if key exists. </span></span><br><span class="line">         *flags |= OBJ_SET_XX;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((opt[<span class="number">0</span>] == <span class="string">&#x27;g&#x27;</span> || opt[<span class="number">0</span>] == <span class="string">&#x27;G&#x27;</span>) &amp;&amp;</span><br><span class="line">                (opt[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span> || opt[<span class="number">1</span>] == <span class="string">&#x27;E&#x27;</span>) &amp;&amp;</span><br><span class="line">                (opt[<span class="number">2</span>] == <span class="string">&#x27;t&#x27;</span> || opt[<span class="number">2</span>] == <span class="string">&#x27;T&#x27;</span>) &amp;&amp; opt[<span class="number">3</span>] == <span class="string">&#x27;\0&#x27;</span> &amp;&amp;</span><br><span class="line">                (command_type == COMMAND_SET))</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// 将flag的GET位设置为1 #define OBJ_SET_GET (1&lt;&lt;5)    -&gt;    Set if want to get key before set</span></span><br><span class="line">         *flags |= OBJ_SET_GET;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(opt, <span class="string">&quot;KEEPTTL&quot;</span>) &amp;&amp; !(*flags &amp; OBJ_PERSIST) &amp;&amp;</span><br><span class="line">         !(*flags &amp; OBJ_EX) &amp;&amp; !(*flags &amp; OBJ_EXAT) &amp;&amp;</span><br><span class="line">         !(*flags &amp; OBJ_PX) &amp;&amp; !(*flags &amp; OBJ_PXAT) &amp;&amp; (command_type == COMMAND_SET))</span><br><span class="line">     &#123;</span><br><span class="line">         *flags |= OBJ_KEEPTTL;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">&quot;PERSIST&quot;</span>) &amp;&amp; (command_type == COMMAND_GET) &amp;&amp;</span><br><span class="line">            !(*flags &amp; OBJ_EX) &amp;&amp; !(*flags &amp; OBJ_EXAT) &amp;&amp;</span><br><span class="line">            !(*flags &amp; OBJ_PX) &amp;&amp; !(*flags &amp; OBJ_PXAT) &amp;&amp;</span><br><span class="line">            !(*flags &amp; OBJ_KEEPTTL))</span><br><span class="line">     &#123;</span><br><span class="line">         *flags |= OBJ_PERSIST;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((opt[<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span> || opt[<span class="number">0</span>] == <span class="string">&#x27;E&#x27;</span>) &amp;&amp;</span><br><span class="line">                (opt[<span class="number">1</span>] == <span class="string">&#x27;x&#x27;</span> || opt[<span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>) &amp;&amp; opt[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span> &amp;&amp;</span><br><span class="line">                !(*flags &amp; OBJ_KEEPTTL) &amp;&amp; !(*flags &amp; OBJ_PERSIST) &amp;&amp;</span><br><span class="line">                !(*flags &amp; OBJ_EXAT) &amp;&amp; !(*flags &amp; OBJ_PX) &amp;&amp;</span><br><span class="line">                !(*flags &amp; OBJ_PXAT) &amp;&amp; next)</span><br><span class="line">     &#123;</span><br><span class="line">         *flags |= OBJ_EX;</span><br><span class="line">         *expire = next;</span><br><span class="line">         j++;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((opt[<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span> || opt[<span class="number">0</span>] == <span class="string">&#x27;P&#x27;</span>) &amp;&amp;</span><br><span class="line">                (opt[<span class="number">1</span>] == <span class="string">&#x27;x&#x27;</span> || opt[<span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>) &amp;&amp; opt[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span> &amp;&amp;</span><br><span class="line">                !(*flags &amp; OBJ_KEEPTTL) &amp;&amp; !(*flags &amp; OBJ_PERSIST) &amp;&amp;</span><br><span class="line">                !(*flags &amp; OBJ_EX) &amp;&amp; !(*flags &amp; OBJ_EXAT) &amp;&amp;</span><br><span class="line">                !(*flags &amp; OBJ_PXAT) &amp;&amp; next)</span><br><span class="line">     &#123;</span><br><span class="line">         *flags |= OBJ_PX;</span><br><span class="line">         *unit = UNIT_MILLISECONDS;</span><br><span class="line">         *expire = next;</span><br><span class="line">         j++;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((opt[<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span> || opt[<span class="number">0</span>] == <span class="string">&#x27;E&#x27;</span>) &amp;&amp;</span><br><span class="line">                (opt[<span class="number">1</span>] == <span class="string">&#x27;x&#x27;</span> || opt[<span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>) &amp;&amp;</span><br><span class="line">                (opt[<span class="number">2</span>] == <span class="string">&#x27;a&#x27;</span> || opt[<span class="number">2</span>] == <span class="string">&#x27;A&#x27;</span>) &amp;&amp;</span><br><span class="line">                (opt[<span class="number">3</span>] == <span class="string">&#x27;t&#x27;</span> || opt[<span class="number">3</span>] == <span class="string">&#x27;T&#x27;</span>) &amp;&amp; opt[<span class="number">4</span>] == <span class="string">&#x27;\0&#x27;</span> &amp;&amp;</span><br><span class="line">                !(*flags &amp; OBJ_KEEPTTL) &amp;&amp; !(*flags &amp; OBJ_PERSIST) &amp;&amp;</span><br><span class="line">                !(*flags &amp; OBJ_EX) &amp;&amp; !(*flags &amp; OBJ_PX) &amp;&amp;</span><br><span class="line">                !(*flags &amp; OBJ_PXAT) &amp;&amp; next)</span><br><span class="line">     &#123;</span><br><span class="line">         *flags |= OBJ_EXAT;</span><br><span class="line">         *expire = next;</span><br><span class="line">         j++;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((opt[<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span> || opt[<span class="number">0</span>] == <span class="string">&#x27;P&#x27;</span>) &amp;&amp;</span><br><span class="line">                (opt[<span class="number">1</span>] == <span class="string">&#x27;x&#x27;</span> || opt[<span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>) &amp;&amp;</span><br><span class="line">                (opt[<span class="number">2</span>] == <span class="string">&#x27;a&#x27;</span> || opt[<span class="number">2</span>] == <span class="string">&#x27;A&#x27;</span>) &amp;&amp;</span><br><span class="line">                (opt[<span class="number">3</span>] == <span class="string">&#x27;t&#x27;</span> || opt[<span class="number">3</span>] == <span class="string">&#x27;T&#x27;</span>) &amp;&amp; opt[<span class="number">4</span>] == <span class="string">&#x27;\0&#x27;</span> &amp;&amp;</span><br><span class="line">                !(*flags &amp; OBJ_KEEPTTL) &amp;&amp; !(*flags &amp; OBJ_PERSIST) &amp;&amp;</span><br><span class="line">                !(*flags &amp; OBJ_EX) &amp;&amp; !(*flags &amp; OBJ_EXAT) &amp;&amp;</span><br><span class="line">                !(*flags &amp; OBJ_PX) &amp;&amp; next)</span><br><span class="line">     &#123;</span><br><span class="line">         *flags |= OBJ_PXAT;</span><br><span class="line">         *unit = UNIT_MILLISECONDS;</span><br><span class="line">         *expire = next;</span><br><span class="line">         j++;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         addReplyErrorObject(c,shared.syntaxerr);</span><br><span class="line">         <span class="keyword">return</span> C_ERR;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-&gt; setCommand -&gt; tryObjectEncoding -&gt; tryObjectEncodingEx :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Try to encode a string object in order to save space */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 尝试对字符串对象进行编码以节省空间</span></span><br><span class="line"><span class="comment">* 参数：</span></span><br><span class="line"><span class="comment">* - o：需要编码的字符串对象。</span></span><br><span class="line"><span class="comment">* - try_trim：是否尝试修剪字符串对象。</span></span><br><span class="line"><span class="comment">* 返回值：返回编码后的对象，如果无法编码则返回原对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">robj *<span class="title">tryObjectEncodingEx</span><span class="params">(robj *o, <span class="keyword">int</span> try_trim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> value;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * o-&gt;ptr 用于获取对象的字符串表示</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * struct redisObject &#123;</span></span><br><span class="line"><span class="comment">     *       unsigned type:4;</span></span><br><span class="line"><span class="comment">     *       unsigned encoding:4;</span></span><br><span class="line"><span class="comment">     *       unsigned lru:LRU_BITS; * LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">     *                              * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">     *                              * and most significant 16 bits access time). *</span></span><br><span class="line"><span class="comment">     *       int refcount;</span></span><br><span class="line"><span class="comment">     *       void *ptr; </span></span><br><span class="line"><span class="comment">     *   &#125;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sds s = o-&gt;ptr;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure this is a string object, the only type we encode</span></span><br><span class="line"><span class="comment">     * in this function. Other types use encoded memory efficient</span></span><br><span class="line"><span class="comment">     * representations but are handled by the commands implementing</span></span><br><span class="line"><span class="comment">     * the type. */</span></span><br><span class="line">    <span class="comment">/* 确保o是一个字符串对象，这是函数能处理的唯一类型 */</span></span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,o,o-&gt;type == OBJ_STRING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We try some specialized encoding only for objects that are</span></span><br><span class="line"><span class="comment">     * RAW or EMBSTR encoded, in other words objects that are still</span></span><br><span class="line"><span class="comment">     * in represented by an actually array of chars. */</span></span><br><span class="line">    <span class="comment">// 只有RAW或EMBSTR编码的对象才会进行特殊的编码</span></span><br><span class="line">    <span class="keyword">if</span> (!sdsEncodedObject(o)) <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* It&#x27;s not safe to encode shared objects: shared objects can be shared</span></span><br><span class="line"><span class="comment">     * everywhere in the &quot;object space&quot; of Redis and may end in places where</span></span><br><span class="line"><span class="comment">     * they are not handled. We handle them only as values in the keyspace. */</span></span><br><span class="line">    <span class="comment">// 不对共享对象进行编码，因为它们可能在Redis的&quot;对象空间&quot;中被共享到任何地方，可能会出现不被处理的情况 </span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount &gt; <span class="number">1</span>) <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we can represent this string as a long integer.</span></span><br><span class="line"><span class="comment">     * Note that we are sure that a string larger than 20 chars is not</span></span><br><span class="line"><span class="comment">     * representable as a 32 nor 64 bit integer. */</span></span><br><span class="line">    <span class="comment">// 检查是否能将字符串表示为长整型</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">20</span> &amp;&amp; string2l(s,len,&amp;value)) &#123;</span><br><span class="line">        <span class="comment">/* This object is encodable as a long. Try to use a shared object.</span></span><br><span class="line"><span class="comment">         * Note that we avoid using shared integers when maxmemory is used</span></span><br><span class="line"><span class="comment">         * because every object needs to have a private LRU field for the LRU</span></span><br><span class="line"><span class="comment">         * algorithm to work well. */</span></span><br><span class="line">        <span class="comment">// 如果对象可以被编码为长整型，并且在可能的情况下尝试使用共享对象</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">         * #define OBJ_SHARED_INTEGERS 10000</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * In Redis, OBJ_SHARED_INTEGERS is a mechanism for optimizing memory usage, especially</span></span><br><span class="line"><span class="comment">         * when dealing with small integer.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Redis pre-creates a certain number of Integer objects (by default,integer from 0 to 10000)</span></span><br><span class="line"><span class="comment">         * upon startup and stores them in an array, This array of shared integers is `shared.integers`.</span></span><br><span class="line"><span class="comment">         * Whenever Redis needs to create an integer within this range, it can simply reference the</span></span><br><span class="line"><span class="comment">         * pre-created object in the `shared.intefers` array instead of allocating new memory.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This way, if multiple keys or multiple list elements refer to the same small integer, they</span></span><br><span class="line"><span class="comment">         * can all share the same object, saving memory.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This optimization is especially useful in applications where small integers are commonly used,</span></span><br><span class="line"><span class="comment">         * as it can significantly reduce the memory usage.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((server.maxmemory == <span class="number">0</span> ||</span><br><span class="line">            !(server.maxmemory_policy &amp; MAXMEMORY_FLAG_NO_SHARED_INTEGERS)) &amp;&amp;</span><br><span class="line">            value &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            value &lt; OBJ_SHARED_INTEGERS)</span><br><span class="line">        &#123;</span><br><span class="line">            decrRefCount(o);</span><br><span class="line">            <span class="keyword">return</span> shared.integers[value];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 数值不在预创建的数值范围之内执行</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_RAW) &#123;</span><br><span class="line">                sdsfree(o-&gt;ptr);</span><br><span class="line">                o-&gt;encoding = OBJ_ENCODING_INT;</span><br><span class="line">                o-&gt;ptr = (<span class="keyword">void</span>*) value;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_EMBSTR) &#123;</span><br><span class="line">                decrRefCount(o);</span><br><span class="line">                <span class="keyword">return</span> createStringObjectFromLongLongForValue(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the string is small and is still RAW encoded,</span></span><br><span class="line"><span class="comment">     * try the EMBSTR encoding which is more efficient.</span></span><br><span class="line"><span class="comment">     * In this representation the object and the SDS string are allocated</span></span><br><span class="line"><span class="comment">     * in the same chunk of memory to save space and cache misses. */</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT) &#123;</span><br><span class="line">        robj *emb;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_EMBSTR) <span class="keyword">return</span> o;</span><br><span class="line">        emb = createEmbeddedStringObject(s,sdslen(s));</span><br><span class="line">        decrRefCount(o);</span><br><span class="line">        <span class="keyword">return</span> emb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We can&#x27;t encode the object...</span></span><br><span class="line"><span class="comment">     * Do the last try, and at least optimize the SDS string inside */</span></span><br><span class="line">    <span class="keyword">if</span> (try_trim)</span><br><span class="line">        trimStringObjectIfNeeded(o, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return the original object. */</span></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>-&gt; setCommand -&gt; tryObjectEncoding -&gt; tryObjectEncodingEx -&gt; createEmbeddedStringObject :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Create a string object with EMBSTR encoding if it is smaller than</span></span><br><span class="line"><span class="comment"> * OBJ_ENCODING_EMBSTR_SIZE_LIMIT, otherwise the RAW encoding is</span></span><br><span class="line"><span class="comment"> * used.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The current limit of 44 is chosen so that the biggest string object</span></span><br><span class="line"><span class="comment"> * we allocate as EMBSTR will still fit into the 64 byte arena of jemalloc.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In Redis, string objects can be encoded in multiple ways, including EMBSTR</span></span><br><span class="line"><span class="comment"> * and RAW. The main difference between these two encodings lies in how they</span></span><br><span class="line"><span class="comment"> * handle and store string data.</span></span><br><span class="line"><span class="comment"> *      1. EMBSTR Encoding: This encoding is designed to optimize the storage of</span></span><br><span class="line"><span class="comment"> *         small strings. When a string&#x27;s length is less than a certain threshold</span></span><br><span class="line"><span class="comment"> *         (default is 44 bytes in Redis source code),Redis uses EMBSTR encoding.</span></span><br><span class="line"><span class="comment"> *         With this encoding, the string object and the string data are stored in</span></span><br><span class="line"><span class="comment"> *         the same memory block, which can reduce memory fragmentation and improve</span></span><br><span class="line"><span class="comment"> *         memory efficiency. However, since the string data is embedded into the</span></span><br><span class="line"><span class="comment"> *         string object, the length of the string cannot be changed after it&#x27;s</span></span><br><span class="line"><span class="comment"> *         created.</span></span><br><span class="line"><span class="comment"> *      2. RAW Encoding: This is a more general encoding that applies to strings of</span></span><br><span class="line"><span class="comment"> *         any length. In this encoding, the string object and the string data are</span></span><br><span class="line"><span class="comment"> *         stored in different memory blocks. This means you can change the length</span></span><br><span class="line"><span class="comment"> *         of the string, but this may lead to more memory fragmentation.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">// 内嵌编码的字符串大小限制</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44</span></span><br><span class="line"><span class="comment">// 创建字符串对象的函数，如果字符串长度小于等于44，创建内嵌字符串对象；否则创建原始字符串对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)</span><br><span class="line">        <span class="keyword">return</span> createEmbeddedStringObject(ptr,len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> createRawStringObject(ptr,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a string object with encoding OBJ_ENCODING_EMBSTR, that is</span></span><br><span class="line"><span class="comment"> * an object where the sds string is actually an unmodifiable string</span></span><br><span class="line"><span class="comment"> * allocated in the same chunk as the object itself. */</span></span><br><span class="line"><span class="comment">/* 创建一个编码为OBJ_ENCODING_EMBSTR的字符串对象，即sds字符串实际上是一个不可修改的字符串，</span></span><br><span class="line"><span class="comment">*  在与对象本身相同的块中分配的。 */</span></span><br><span class="line"><span class="function">robj *<span class="title">createEmbeddedStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为对象和字符串数据分配内存</span></span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(robj)+<span class="keyword">sizeof</span>(struct sdshdr8)+len+<span class="number">1</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr8</span> *<span class="title">sh</span> =</span> (<span class="keyword">void</span>*)(o+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 设置对象的类型、编码、指针、引用计数、LRU</span></span><br><span class="line">    o-&gt;type = OBJ_STRING;</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_EMBSTR;</span><br><span class="line">    o-&gt;ptr = sh+<span class="number">1</span>;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">    o-&gt;lru = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置sds头部的长度、分配的内存大小、标志位</span></span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    sh-&gt;alloc = len;</span><br><span class="line">    sh-&gt;flags = SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">if</span> (ptr == SDS_NOINIT)</span><br><span class="line">        sh-&gt;buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">        <span class="comment">// 如果ptr非空，复制ptr中的数据到buf，并在末尾添加&#x27;\0&#x27;</span></span><br><span class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf,ptr,len);</span><br><span class="line">        sh-&gt;buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果ptr为空，将buf设置为全0</span></span><br><span class="line">        <span class="built_in">memset</span>(sh-&gt;buf,<span class="number">0</span>,len+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>-&gt; setCommand -&gt; setGenericCommand :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 通用的Set命令处理函数</span></span><br><span class="line"><span class="comment"> * 参数:</span></span><br><span class="line"><span class="comment"> * - c: 客户端对象</span></span><br><span class="line"><span class="comment"> * - flags: Set命令的选项</span></span><br><span class="line"><span class="comment"> * - key: 键</span></span><br><span class="line"><span class="comment"> * - val: 值</span></span><br><span class="line"><span class="comment"> * - expire: 过期时间</span></span><br><span class="line"><span class="comment"> * - unit: 过期时间的单位</span></span><br><span class="line"><span class="comment"> * - ok_reply: 成功回复</span></span><br><span class="line"><span class="comment"> * - abort_reply: 失败回复</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> flags, robj *key, robj *val, robj *expire, <span class="keyword">int</span> unit, robj *ok_reply, robj *abort_reply)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化过期时间变量</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> milliseconds = <span class="number">0</span>; <span class="comment">/* initialized to avoid any harmness warning */</span></span><br><span class="line">    <span class="comment">// 初始化键是否存在的标记</span></span><br><span class="line">    <span class="keyword">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始化setkey_flags</span></span><br><span class="line">    <span class="keyword">int</span> setkey_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果有设置过期时间，获取过期时间的毫秒值，如果获取失败，返回</span></span><br><span class="line">    <span class="keyword">if</span> (expire &amp;&amp; getExpireMillisecondsOrReply(c, expire, flags, unit, &amp;milliseconds) != C_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果设置了GET选项，调用getGenericCommand函数获取键的值，如果获取失败，则直接返回</span></span><br><span class="line"><span class="comment">     * SET命令可以配合GET参数一起使用，这样在设置新值的同时，返回该键的旧值。</span></span><br><span class="line"><span class="comment">     * getGenericCommand(c)是一个函数调用，它尝试获取并返回客户端请求的键的值。如果键不存在，函数将返回错误C_ERR。</span></span><br><span class="line"><span class="comment">     * 所以if (getGenericCommand(c) == C_ERR) return;这行代码的作用是，如果在尝试获取键的值时遇到错误(检查到值的类型错误)，</span></span><br><span class="line"><span class="comment">     * 那么就立即停止执行当前函数并返回，不再继续执行后面的代码。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; OBJ_SET_GET) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getGenericCommand(c) == C_ERR) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用lookupKeyWrite函数查找键是否存在，如果存在，将found标记设置为1</span></span><br><span class="line">    found = (lookupKeyWrite(c-&gt;db,key) != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 如果设置了NX选项且键存在，或设置了XX选项且键不存在，发送abort_reply或null回复，并返回</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; OBJ_SET_NX &amp;&amp; found) ||</span><br><span class="line">        (flags &amp; OBJ_SET_XX &amp;&amp; !found))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(flags &amp; OBJ_SET_GET)) &#123;</span><br><span class="line">            addReply(c, abort_reply ? abort_reply : shared.null[c-&gt;resp]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When expire is not NULL, we avoid deleting the TTL so it can be updated later instead of being deleted and then created again. */</span></span><br><span class="line">    <span class="comment">// 设置setKey函数的选项</span></span><br><span class="line">    setkey_flags |= ((flags &amp; OBJ_KEEPTTL) || expire) ? SETKEY_KEEPTTL : <span class="number">0</span>;</span><br><span class="line">    setkey_flags |= found ? SETKEY_ALREADY_EXIST : SETKEY_DOESNT_EXIST;</span><br><span class="line"></span><br><span class="line">    setKey(c,c-&gt;db,key,val,setkey_flags);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * RDB persistence</span></span><br><span class="line"><span class="comment">     * the server.dirty variable is used to keep track of the number of changes to database</span></span><br><span class="line"><span class="comment">     * since the last save. It&#x27;s incremented every time a command that modifies the database</span></span><br><span class="line"><span class="comment">     * is executed.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * long long dirty;       -&gt;     Changes to DB from the last save </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    server.dirty++;</span><br><span class="line">    <span class="comment">// 发送set事件通知</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_STRING,<span class="string">&quot;set&quot;</span>,key,c-&gt;db-&gt;id);</span><br><span class="line">    <span class="comment">// 如果设置了过期时间，调用setExpire函数设置键的过期时间，发送expire事件通知</span></span><br><span class="line">    <span class="keyword">if</span> (expire) &#123;</span><br><span class="line">        setExpire(c,c-&gt;db,key,milliseconds);</span><br><span class="line">        <span class="comment">/* Propagate as SET Key Value PXAT millisecond-timestamp if there is</span></span><br><span class="line"><span class="comment">         * EX/PX/EXAT flag. */</span></span><br><span class="line">        <span class="comment">// 如果没有设置PXAT选项，重写客户端的命令参数，添加PXAT和过期时间</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 重写命令参数的目的有两个：</span></span><br><span class="line"><span class="comment">         * 保持一致性：当Redis执行命令时，它会修改内存中的数据，同时也可能会修改磁盘上的数据（例如，AOF持久化）。</span></span><br><span class="line"><span class="comment">         * 如果命令参数在执行过程中发生了变化，那么内存中的数据和磁盘上的数据可能会不一致。为了避免这种情况，Redis会在执行命令之前，</span></span><br><span class="line"><span class="comment">         * 将命令参数重写为最终的形式。方便复制：Redis支持主从复制，即将一台Redis服务器的数据复制到其他的Redis服务器。</span></span><br><span class="line"><span class="comment">         * 复制时，主服务器会将执行的命令发送给从服务器。如果命令参数在执行过程中发生了变化，那么主服务器发送给从服务器的命令应该包含这些变化。</span></span><br><span class="line"><span class="comment">         * 为了实现这一点，Redis会在执行命令之前，将命令参数重写为最终的形式。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!(flags &amp; OBJ_PXAT)) &#123;</span><br><span class="line">            robj *milliseconds_obj = createStringObjectFromLongLong(milliseconds);</span><br><span class="line">            rewriteClientCommandVector(c, <span class="number">5</span>, shared.<span class="built_in">set</span>, key, val, shared.pxat, milliseconds_obj);</span><br><span class="line">            decrRefCount(milliseconds_obj);</span><br><span class="line">        &#125;</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">&quot;expire&quot;</span>,key,c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有设置GET选项，发送ok_reply或ok回复</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; OBJ_SET_GET)) &#123;</span><br><span class="line">        addReply(c, ok_reply ? ok_reply : shared.ok);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果设置了GET选项，但没有设置过期时间，重写客户端的命令参数，去掉GET选项</span></span><br><span class="line">    <span class="comment">// 如果包含了过期时间，在上面的代码处理已经重写过命令了，在此处无需重写</span></span><br><span class="line">    <span class="comment">/* Propagate without the GET argument (Isn&#x27;t needed if we had expire since in that case we completely re-written the command argv) */</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; OBJ_SET_GET) &amp;&amp; !expire) &#123;</span><br><span class="line">        <span class="keyword">int</span> argc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        robj **argv = zmalloc((c-&gt;argc<span class="number">-1</span>)*<span class="keyword">sizeof</span>(robj*));</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> *a = c-&gt;argv[j]-&gt;ptr;</span><br><span class="line">            <span class="comment">/* Skip GET which may be repeated multiple times. */</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= <span class="number">3</span> &amp;&amp;</span><br><span class="line">                (a[<span class="number">0</span>] == <span class="string">&#x27;g&#x27;</span> || a[<span class="number">0</span>] == <span class="string">&#x27;G&#x27;</span>) &amp;&amp;</span><br><span class="line">                (a[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span> || a[<span class="number">1</span>] == <span class="string">&#x27;E&#x27;</span>) &amp;&amp;</span><br><span class="line">                (a[<span class="number">2</span>] == <span class="string">&#x27;t&#x27;</span> || a[<span class="number">2</span>] == <span class="string">&#x27;T&#x27;</span>) &amp;&amp; a[<span class="number">3</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            argv[argc++] = c-&gt;argv[j];</span><br><span class="line">            incrRefCount(c-&gt;argv[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用新的参数数组替换原参数数组</span></span><br><span class="line">        replaceClientCommandVector(c, argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-&gt; setCommand -&gt; setGenericCommand -&gt; getGenericCommand<br>-&gt; lookupKeyReadOrReply -&gt; lookupKeyRead -&gt; lookupKeyReadWithFlags<br>-&gt; lookupKey:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Lookup a key for read or write operations, or return NULL if the key is not</span></span><br><span class="line"><span class="comment"> * found in the specified DB. This function implements the functionality of</span></span><br><span class="line"><span class="comment"> * lookupKeyRead(), lookupKeyWrite() and their ...WithFlags() variants.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Side-effects of calling this function:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. A key gets expired if it reached it&#x27;s TTL.</span></span><br><span class="line"><span class="comment"> * 2. The key&#x27;s last access time is updated.</span></span><br><span class="line"><span class="comment"> * 3. The global keys hits/misses stats are updated (reported in INFO).</span></span><br><span class="line"><span class="comment"> * 4. If keyspace notifications are enabled, a &quot;keymiss&quot; notification is fired.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Flags change the behavior of this command:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  LOOKUP_NONE (or zero): No special flags are passed.</span></span><br><span class="line"><span class="comment"> *  LOOKUP_NOTOUCH: Don&#x27;t alter the last access time of the key.</span></span><br><span class="line"><span class="comment"> *  LOOKUP_NONOTIFY: Don&#x27;t trigger keyspace event on key miss.</span></span><br><span class="line"><span class="comment"> *  LOOKUP_NOSTATS: Don&#x27;t increment key hits/misses counters.</span></span><br><span class="line"><span class="comment"> *  LOOKUP_WRITE: Prepare the key for writing (delete expired keys even on</span></span><br><span class="line"><span class="comment"> *                replicas, use separate keyspace stats and events (TODO)).</span></span><br><span class="line"><span class="comment"> *  LOOKUP_NOEXPIRE: Perform expiration check, but avoid deleting the key,</span></span><br><span class="line"><span class="comment"> *                   so that we don&#x27;t have to propagate the deletion.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: this function also returns NULL if the key is logically expired but</span></span><br><span class="line"><span class="comment"> * still existing, in case this is a replica and the LOOKUP_WRITE is not set.</span></span><br><span class="line"><span class="comment"> * Even if the key expiry is master-driven, we can correctly report a key is</span></span><br><span class="line"><span class="comment"> * expired on replicas even if the master is lagging expiring our key via DELs</span></span><br><span class="line"><span class="comment"> * in the replication link. */</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKey</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在Redis数据库的字典中查找键对应的字典条目</span></span><br><span class="line">    dictEntry *de = dictFind(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    <span class="comment">// 初始化对应的值为NULL</span></span><br><span class="line">    robj *val = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 如果在字典中找到了对应的字典条目</span></span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        <span class="comment">// 从字典中获取值</span></span><br><span class="line">        val = dictGetVal(de);</span><br><span class="line">        <span class="comment">/* Forcing deletion of expired keys on a replica makes the replica</span></span><br><span class="line"><span class="comment">         * inconsistent with the master. We forbid it on readonly replicas, but</span></span><br><span class="line"><span class="comment">         * we have to allow it on writable replicas to make write commands</span></span><br><span class="line"><span class="comment">         * behave consistently.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * It&#x27;s possible that the WRITE flag is set even during a readonly</span></span><br><span class="line"><span class="comment">         * command, since the command may trigger events that cause modules to</span></span><br><span class="line"><span class="comment">         * perform additional writes. */</span></span><br><span class="line">        <span class="comment">// 查看是否为只读副本，如果是只读副本，强制删除过期键可能会导致副本与主服务器的数据不一致</span></span><br><span class="line">        <span class="keyword">int</span> is_ro_replica = server.masterhost &amp;&amp; server.repl_slave_ro;</span><br><span class="line">        <span class="keyword">int</span> expire_flags = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果是写操作，并且不是只读副本，强制删除过期的键。</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; LOOKUP_WRITE &amp;&amp; !is_ro_replica)</span><br><span class="line">            expire_flags |= EXPIRE_FORCE_DELETE_EXPIRED;</span><br><span class="line">        <span class="comment">// 如果设置了LOOKUP_NOEXPIRE标志，避免删除过期的键。</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; LOOKUP_NOEXPIRE)</span><br><span class="line">            expire_flags |= EXPIRE_AVOID_DELETE_EXPIRED;</span><br><span class="line">        <span class="comment">// 检查键是否已经过期，如果已经过期，则将值设置为NULL。</span></span><br><span class="line">        <span class="keyword">if</span> (expireIfNeeded(db, key, expire_flags)) &#123;</span><br><span class="line">            <span class="comment">/* The key is no longer valid. */</span></span><br><span class="line">            val = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (val) &#123;</span><br><span class="line">        <span class="comment">/* Update the access time for the ageing algorithm.</span></span><br><span class="line"><span class="comment">         * Don&#x27;t do it if we have a saving child, as this will trigger</span></span><br><span class="line"><span class="comment">         * a copy on write madness. */</span></span><br><span class="line">        <span class="comment">// 如果键值存在且未过期</span></span><br><span class="line">        <span class="comment">// 更新键的访问时间，以便于实现LRU（最近最少使用）策略。但是，如果服务器当前有子进程在运行（比如执行RDB或者AOF持久化操作）</span></span><br><span class="line">        <span class="comment">// 则不更新访问时间，以避免触发COW（写时复制）开销 [<span class="doctag">TODO:</span> 待确认 感觉读到RDB和AOF时能解决]</span></span><br><span class="line">        <span class="comment">// 如果客户端设置了CLIENT_NO_TOUCH标志，并且当前命令不是TOUCH命令，那么不更新时间</span></span><br><span class="line">        <span class="keyword">if</span> (server.current_client &amp;&amp; server.current_client-&gt;flags &amp; CLIENT_NO_TOUCH &amp;&amp;</span><br><span class="line">            server.current_client-&gt;cmd-&gt;proc != touchCommand)</span><br><span class="line">            <span class="comment">// 如果我们只是想检查一个键是否存在，但并不希望影响它的过期时间，那么就可以使用CLIENT_NO_TOUCH标志</span></span><br><span class="line">            flags |= LOOKUP_NOTOUCH;</span><br><span class="line">        <span class="comment">// 如果没有子进程在运行，并且没有设置LOOKUP_NOTOUCH标志，则更新访问时间</span></span><br><span class="line">        <span class="keyword">if</span> (!hasActiveChildProcess() &amp;&amp; !(flags &amp; LOOKUP_NOTOUCH))&#123;</span><br><span class="line">            <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">                <span class="comment">// 如果内存淘汰策略是LFU（Least Frequently Used，最不经常使用），则更新LFU频率计数器</span></span><br><span class="line">                updateLFU(val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则，更新LRU（Least Recently Used，最近最少使用）时钟</span></span><br><span class="line">                val-&gt;lru = LRU_CLOCK();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有设置LOOKUP_NOSTATS和LOOKUP_WRITE标志，增加键空间命中次数</span></span><br><span class="line">        <span class="keyword">if</span> (!(flags &amp; (LOOKUP_NOSTATS | LOOKUP_WRITE)))</span><br><span class="line">            server.stat_keyspace_hits++;</span><br><span class="line">        <span class="comment">/* <span class="doctag">TODO:</span> Use separate hits stats for WRITE */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有设置LOOKUP_NONOTIFY和LOOKUP_WRITE标志，发送键空间未命中事件</span></span><br><span class="line">        <span class="keyword">if</span> (!(flags &amp; (LOOKUP_NONOTIFY | LOOKUP_WRITE)))</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_KEY_MISS, <span class="string">&quot;keymiss&quot;</span>, key, db-&gt;id);</span><br><span class="line">        <span class="comment">// 如果没有设置LOOKUP_NOSTATS和LOOKUP_WRITE标志，增加键空间未命中次数，常常用于计算Redis的&quot;命中率&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (!(flags &amp; (LOOKUP_NOSTATS | LOOKUP_WRITE)))</span><br><span class="line">            server.stat_keyspace_misses++;</span><br><span class="line">        <span class="comment">/* <span class="doctag">TODO:</span> Use separate misses stats and notify event for WRITE */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>-&gt; setCommand -&gt; setGenericCommand -&gt; getGenericCommand<br>-&gt; lookupKeyReadOrReply -&gt; lookupKeyRead -&gt; lookupKeyReadWithFlags<br>-&gt; lookupKey -&gt; dictFind:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictFind</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化字典条目和哈希值变量</span></span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">uint64_t</span> h, idx, table;</span><br><span class="line">    <span class="comment">// 如果字典为空则返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* dict is empty */</span></span><br><span class="line">    <span class="comment">// 如果字典正在进行rehash操作，执行一步rehash</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    <span class="comment">// 计算键的hash值</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="comment">// 遍历两个hash表</span></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        <span class="comment">// 计算正在hash中的索引值</span></span><br><span class="line">        idx = h &amp; DICTHT_SIZE_MASK(d-&gt;ht_size_exp[table]);</span><br><span class="line">        <span class="comment">// 获取索引位置的字典条目 dictEntry</span></span><br><span class="line">        he = d-&gt;ht_table[table][idx];</span><br><span class="line">        <span class="comment">// 在对应字典条目的链表上查找键</span></span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">void</span> *he_key = dictGetKey(he);</span><br><span class="line">            <span class="comment">// 如果查找到了对应的键，则返回对应的dict_entry</span></span><br><span class="line">            <span class="keyword">if</span> (key == he_key || dictCompareKeys(d, key, he_key))</span><br><span class="line">                <span class="keyword">return</span> he;</span><br><span class="line">            he = dictGetNext(he);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找不到对应的键则返回为空</span></span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>-&gt; setCommand -&gt; setGenericCommand -&gt; getGenericCommand<br>-&gt; lookupKeyReadOrReply -&gt; lookupKeyRead -&gt; lookupKeyReadWithFlags<br>-&gt; lookupKey -&gt; dictFind -&gt; _dictRehashStep -&gt; dictRehash:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Performs N steps of incremental rehashing. Returns 1 if there are still</span></span><br><span class="line"><span class="comment"> * keys to move from the old to the new hash table, otherwise 0 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that a rehashing step consists in moving a bucket (that may have more</span></span><br><span class="line"><span class="comment"> * than one key as we use chaining) from the old to the new hash table, however</span></span><br><span class="line"><span class="comment"> * since part of the hash table may be composed of empty spaces, it is not</span></span><br><span class="line"><span class="comment"> * guaranteed that this function will rehash even a single bucket, since it</span></span><br><span class="line"><span class="comment"> * will visit at max N*10 empty buckets in total, otherwise the amount of</span></span><br><span class="line"><span class="comment"> * work it does would be unbound and the function may block for a long time. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * In order to avoid the invalid view as there are too many empty buckets in hash table.</span></span><br><span class="line"><span class="comment">     * Redis control it by empty_visits = n * 10. It means that it can view n * 10 buckets</span></span><br><span class="line"><span class="comment">     * per dictRehash function call.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 访问空桶的最大次数，控制函数的运行时间</span></span><br><span class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="comment">/* get ht1 and ht2 size */</span></span><br><span class="line">    <span class="comment">// 获取h1和h2hash表的大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> s0 = DICTHT_SIZE(d-&gt;ht_size_exp[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> s1 = DICTHT_SIZE(d-&gt;ht_size_exp[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 判断是否可以进行rehash操作</span></span><br><span class="line">    <span class="comment">/* DICT_RESIZE_FORBID:</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * In Redis, DICT_RESIZE_FORBID is a flag that is used to prevent resizing</span></span><br><span class="line"><span class="comment">     * of the dictionary.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For instance, The certain operations like database saving or replication,</span></span><br><span class="line"><span class="comment">     * resizing could lead to issues, so forbid it.</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * void updateDictResizePolicy(void) &#123;</span></span><br><span class="line"><span class="comment">     *     // int in_fork_child;    -&gt; indication that this is a fork child </span></span><br><span class="line"><span class="comment">     *     if (server.in_fork_child != CHILD_TYPE_NONE) 如果是子进程设置为DICT_RESIZE_FORBID</span></span><br><span class="line"><span class="comment">     *         dictSetResizeEnabled(DICT_RESIZE_FORBID);</span></span><br><span class="line"><span class="comment">     *     else if (hasActiveChildProcess()) 如果有正在活跃的子进程则设置成DICT_RESIZE_AVOID</span></span><br><span class="line"><span class="comment">     *         dictSetResizeEnabled(DICT_RESIZE_AVOID);</span></span><br><span class="line"><span class="comment">     *     else</span></span><br><span class="line"><span class="comment">     *         dictSetResizeEnabled(DICT_RESIZE_ENABLE);</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     * // Return true if there are active children processes doing RDB saving,</span></span><br><span class="line"><span class="comment">     * // AOF rewriting, or some side process spawned by a loaded module.</span></span><br><span class="line"><span class="comment">     * int hasActiveChildProcess(void) &#123;</span></span><br><span class="line"><span class="comment">     *      return server.child_pid != -1;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dict_can_resize == DICT_RESIZE_FORBID || !dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// static unsigned int dict_force_resize_ratio = 5;</span></span><br><span class="line">    <span class="comment">// s0和s1分别表示旧的哈希表和新的哈希表的大小。dict_force_resize_ratio是一个阈值，用于控制在何种情况下可以强制进行resize操作。</span></span><br><span class="line">    <span class="comment">// 如果当前设置为应避免resize操作，并且新旧哈希表的大小比（无论是s1/s0还是s0/s1）没有超过dict_force_resize_ratio，</span></span><br><span class="line">    <span class="comment">// 那么就直接返回0，不进行后续的rehash操作。换句话说，即使当前的哈希表大小不是最优的，</span></span><br><span class="line">    <span class="comment">// 但只要新旧表的大小比没有超过一定的阈值，那么为了避免耗费过多的资源进行resize，就选择不进行resize操作。</span></span><br><span class="line">    <span class="comment">// 这是一种权衡，通过牺牲一些内存效率，以换取在繁忙时期更好的CPU性能。</span></span><br><span class="line">    <span class="keyword">if</span> (dict_can_resize == DICT_RESIZE_AVOID &amp;&amp; </span><br><span class="line">        ((s1 &gt; s0 &amp;&amp; s1 / s0 &lt; dict_force_resize_ratio) ||</span><br><span class="line">         (s1 &lt; s0 &amp;&amp; s0 / s1 &lt; dict_force_resize_ratio)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行n步重哈希操作</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * d-&gt;ht_used 是一个数组，用来分别存储Redis中哈希表的两个部分（ht[0] 和 ht[1]）中的元素数量。</span></span><br><span class="line"><span class="comment">     * 在Redis的哈希表实现中，为了避免rehash操作造成的长时间阻塞，采用了渐进式的rehash策略，即新旧两个哈希表同时存在，查询时两个哈希表都要查，</span></span><br><span class="line"><span class="comment">     * 但是插入只在新表中操作，旧表中的元素会在后续的操作中逐渐迁移到新表。</span></span><br><span class="line"><span class="comment">     * d-&gt;ht_used[0] 表示旧哈希表（ht[0]）中当前存储的元素数量，d-&gt;ht_used[1] 表示新哈希表（ht[1]）中当前存储的元素数量。</span></span><br><span class="line"><span class="comment">     * 在rehash过程中，随着旧表的元素逐渐迁移到新表，d-&gt;ht_used[0] 会逐渐减小，d-&gt;ht_used[1]会逐渐增大。</span></span><br><span class="line"><span class="comment">     * 当d-&gt;ht_used[0]减小到0时，表示rehash操作完成。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht_used[<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can&#x27;t overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        <span class="comment">// 确保d-&gt;rehashidx不会溢出</span></span><br><span class="line">        assert(DICTHT_SIZE(d-&gt;ht_size_exp[<span class="number">0</span>]) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="comment">// 跳过空桶</span></span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht_table[<span class="number">0</span>][d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取当前桶中的第一个字典条目(dict_entry)</span></span><br><span class="line">        de = d-&gt;ht_table[<span class="number">0</span>][d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="comment">// 移动桶中的所有键到新哈希表</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> h;</span><br><span class="line">            <span class="comment">// 获取下一个dict_entry</span></span><br><span class="line">            nextde = dictGetNext(de);</span><br><span class="line">            <span class="keyword">void</span> *key = dictGetKey(de);</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            <span class="comment">// 计算键在新哈希表中的位置</span></span><br><span class="line">            <span class="keyword">if</span> (d-&gt;ht_size_exp[<span class="number">1</span>] &gt; d-&gt;ht_size_exp[<span class="number">0</span>]) &#123;</span><br><span class="line">                h = dictHashKey(d, key) &amp; DICTHT_SIZE_MASK(d-&gt;ht_size_exp[<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* We&#x27;re shrinking the table. The tables sizes are powers of</span></span><br><span class="line"><span class="comment">                 * two, so we simply mask the bucket index in the larger table</span></span><br><span class="line"><span class="comment">                 * to get the bucket index in the smaller table. */</span></span><br><span class="line">                h = d-&gt;rehashidx &amp; DICTHT_SIZE_MASK(d-&gt;ht_size_exp[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果字典的类型是不存储值的类型，则进行以下操作。</span></span><br><span class="line">            <span class="comment">/* The &#x27;no_value&#x27; flag, if set, indicates that values are not used, i.e. the</span></span><br><span class="line"><span class="comment">             * dict is a set. When this flag is set, it&#x27;s not possible to access the</span></span><br><span class="line"><span class="comment">             * value of a dictEntry and it&#x27;s also impossible to use dictSetKey(). Entry</span></span><br><span class="line"><span class="comment">             * metadata can also not be used. */</span></span><br><span class="line">            <span class="keyword">if</span> (d-&gt;type-&gt;no_value) &#123;</span><br><span class="line">                <span class="comment">// 如果键是奇数并且目标bucket为空，则直接将键存储在目标bucket，不需要分配新的entry。（rehash的位置取决于高位）</span></span><br><span class="line">                <span class="keyword">if</span> (d-&gt;type-&gt;keys_are_odd &amp;&amp; !d-&gt;ht_table[<span class="number">1</span>][h]) &#123;</span><br><span class="line">                    <span class="comment">/* Destination bucket is empty and we can store the key</span></span><br><span class="line"><span class="comment">                     * directly without an allocated entry. Free the old entry</span></span><br><span class="line"><span class="comment">                     * if it&#x27;s an allocated entry.</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">TODO:</span> Add a flag &#x27;keys_are_even&#x27; and if set, we can use</span></span><br><span class="line"><span class="comment">                     * this optimization for these dicts too. We can set the LSB</span></span><br><span class="line"><span class="comment">                     * bit when stored as a dict entry and clear it again when</span></span><br><span class="line"><span class="comment">                     * we need the key back. */</span></span><br><span class="line">                    <span class="comment">/* Returns 1 if the entry pointer is a pointer to a key, rather than to an</span></span><br><span class="line"><span class="comment">                     * allocated entry. Returns 0 otherwise. </span></span><br><span class="line"><span class="comment">                     * </span></span><br><span class="line"><span class="comment">                     * #define ENTRY_PTR_MASK     7 -&gt;  111 </span></span><br><span class="line"><span class="comment">                     * #define ENTRY_PTR_NORMAL   0 -&gt;  000 </span></span><br><span class="line"><span class="comment">                     * #define ENTRY_PTR_NO_VALUE 2 -&gt;  010 </span></span><br><span class="line"><span class="comment">                     * static inline int entryIsKey(const dictEntry *de) &#123;</span></span><br><span class="line"><span class="comment">                     *      return (uintptr_t)(void *)de &amp; 1;</span></span><br><span class="line"><span class="comment">                     *  &#125;</span></span><br><span class="line"><span class="comment">                     **/</span></span><br><span class="line">                    assert(entryIsKey(key));</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> 这里的操作不是很懂，等看到set集合时得关注下。</span></span><br><span class="line">                    <span class="keyword">if</span> (!entryIsKey(de)) zfree(decodeMaskedPtr(de));</span><br><span class="line">                    de = key;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entryIsKey(de)) &#123;</span><br><span class="line">                    <span class="comment">/* We don&#x27;t have an allocated entry but we need one. */</span></span><br><span class="line">                    <span class="comment">// 如果我们没有分配的entry但是我们需要一个，则创建一个不存储值的entry。</span></span><br><span class="line">                    de = createEntryNoValue(key, d-&gt;ht_table[<span class="number">1</span>][h]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 将已有的entry移动到目标bucket，并更新&#x27;next&#x27;字段。</span></span><br><span class="line">                    <span class="comment">/* Just move the existing entry to the destination table and</span></span><br><span class="line"><span class="comment">                     * update the &#x27;next&#x27; field. */</span></span><br><span class="line">                    assert(entryIsNoValue(de));</span><br><span class="line">                    dictSetNext(de, d-&gt;ht_table[<span class="number">1</span>][h]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dictSetNext(de, d-&gt;ht_table[<span class="number">1</span>][h]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将entry放入新哈希表的相应位置。</span></span><br><span class="line">            d-&gt;ht_table[<span class="number">1</span>][h] = de;</span><br><span class="line">            <span class="comment">// 更新旧哈希表和新哈希表中键的数量。</span></span><br><span class="line">            d-&gt;ht_used[<span class="number">0</span>]--;</span><br><span class="line">            d-&gt;ht_used[<span class="number">1</span>]++;</span><br><span class="line">            <span class="comment">// 移动到下一个entry。</span></span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前bucket置为空，并将rehashidx加1，表示该bucket已经完成rehash。</span></span><br><span class="line">        d-&gt;ht_table[<span class="number">0</span>][d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="comment">// 如果旧哈希表中已经没有键了，表示rehash操作已经完成。</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht_used[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 释放旧哈希表的空间。</span></span><br><span class="line">        zfree(d-&gt;ht_table[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">/* Copy the new ht onto the old one */</span></span><br><span class="line">        <span class="comment">// 将新哈希表复制到旧哈希表的位置。</span></span><br><span class="line">        d-&gt;ht_table[<span class="number">0</span>] = d-&gt;ht_table[<span class="number">1</span>];</span><br><span class="line">        d-&gt;ht_used[<span class="number">0</span>] = d-&gt;ht_used[<span class="number">1</span>];</span><br><span class="line">        d-&gt;ht_size_exp[<span class="number">0</span>] = d-&gt;ht_size_exp[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 重置新哈希表。</span></span><br><span class="line">        _dictReset(d, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将rehashidx设为-1，表示当前没有进行rehash操作。</span></span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="comment">// 如果旧哈希表中还有未移动的键，表示还有更多的rehash操作需要进行。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>-&gt; setCommand -&gt; setGenericCommand -&gt; getGenericCommand<br>-&gt; lookupKeyReadOrReply -&gt; lookupKeyRead -&gt; lookupKeyReadWithFlags<br>-&gt; lookupKey -&gt; expireIfNeeded:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* This function is called when we are going to perform some operation</span></span><br><span class="line"><span class="comment"> * in a given key, but such key may be already logically expired even if</span></span><br><span class="line"><span class="comment"> * it still exists in the database. The main way this function is called</span></span><br><span class="line"><span class="comment"> * is via lookupKey*() family of functions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The behavior of the function depends on the replication role of the</span></span><br><span class="line"><span class="comment"> * instance, because by default replicas do not delete expired keys. They</span></span><br><span class="line"><span class="comment"> * wait for DELs from the master for consistency matters. However even</span></span><br><span class="line"><span class="comment"> * replicas will try to have a coherent return value for the function,</span></span><br><span class="line"><span class="comment"> * so that read commands executed in the replica side will be able to</span></span><br><span class="line"><span class="comment"> * behave like if the key is expired even if still present (because the</span></span><br><span class="line"><span class="comment"> * master has yet to propagate the DEL).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In masters as a side effect of finding a key which is expired, such</span></span><br><span class="line"><span class="comment"> * key will be evicted from the database. Also this may trigger the</span></span><br><span class="line"><span class="comment"> * propagation of a DEL/UNLINK command in AOF / replication stream.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On replicas, this function does not delete expired keys by default, but</span></span><br><span class="line"><span class="comment"> * it still returns 1 if the key is logically expired. To force deletion</span></span><br><span class="line"><span class="comment"> * of logically expired keys even on replicas, use the EXPIRE_FORCE_DELETE_EXPIRED</span></span><br><span class="line"><span class="comment"> * flag. Note though that if the current client is executing</span></span><br><span class="line"><span class="comment"> * replicated commands from the master, keys are never considered expired.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On the other hand, if you just want expiration check, but need to avoid</span></span><br><span class="line"><span class="comment"> * the actual key deletion and propagation of the deletion, use the</span></span><br><span class="line"><span class="comment"> * EXPIRE_AVOID_DELETE_EXPIRED flag.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The return value of the function is 0 if the key is still valid,</span></span><br><span class="line"><span class="comment"> * otherwise the function returns 1 if the key is expired. */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此函数用于字典键值对的过期</span></span><br><span class="line"><span class="comment"> * @param db 为redis数据库</span></span><br><span class="line"><span class="comment"> * @param key 为要过期的键</span></span><br><span class="line"><span class="comment"> * @param flags 为操作标志位</span></span><br><span class="line"><span class="comment"> * @return 如果键已经删除，则返回1，否则返回0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果服务器禁用了延迟过期则返回0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis有两种过期策略</span></span><br><span class="line"><span class="comment">     * 1. 被动过期</span></span><br><span class="line"><span class="comment">     *     当访问一个键时，redis会检查一个键是否过期，如果已过期则删除，这种方式称作为懒惰过期</span></span><br><span class="line"><span class="comment">     * 2. 主动过期</span></span><br><span class="line"><span class="comment">     *     Redis会定期扫描数据库，删除已过期的键，这种方式redis会主动寻找并删除过期键</span></span><br><span class="line"><span class="comment">     *     </span></span><br><span class="line"><span class="comment">     * server.lazy_expire_disabled = 1 时表示延迟过期被禁用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (server.lazy_expire_disabled) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断键是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (!keyIsExpired(db,key)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are running in the context of a replica, instead of</span></span><br><span class="line"><span class="comment">     * evicting the expired key from the database, we return ASAP:</span></span><br><span class="line"><span class="comment">     * the replica key expiration is controlled by the master that will</span></span><br><span class="line"><span class="comment">     * send us synthesized DEL operations for expired keys. The</span></span><br><span class="line"><span class="comment">     * exception is when write operations are performed on writable</span></span><br><span class="line"><span class="comment">     * replicas.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Still we try to return the right information to the caller,</span></span><br><span class="line"><span class="comment">     * that is, 0 if we think the key should be still valid, 1 if</span></span><br><span class="line"><span class="comment">     * we think the key is expired at this time.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * When replicating commands from the master, keys are never considered</span></span><br><span class="line"><span class="comment">     * expired. */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When the masterhost is not null, it means that this server is a replica.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 判断是否为主服务器，如果server.masterhost不为空，则当前的服务为副本服务，副本服务不会主动清除</span></span><br><span class="line">    <span class="comment">// 键，一般副本清除键由主服务器发送的DEL控制。</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * current_client is the client where the command from</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="comment">// 如果命令来自于主服务器（主服务器为客户端），则直接返回0，表示未进行键过期</span></span><br><span class="line">        <span class="keyword">if</span> (server.current_client &amp;&amp; (server.current_client-&gt;flags &amp; CLIENT_MASTER)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果没有设置强制过期键的标识，则返回1，表示为键已过期，但这里并没有清除键的动作</span></span><br><span class="line">        <span class="keyword">if</span> (!(flags &amp; EXPIRE_FORCE_DELETE_EXPIRED)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In some cases we&#x27;re explicitly instructed to return an indication of a</span></span><br><span class="line"><span class="comment">     * missing key without actually deleting it, even on masters. */</span></span><br><span class="line">    <span class="comment">// 如果操作标识包含了避免过期键的动作，则返回1，表示为键已过期，但这里并没有进行过期键操作</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; EXPIRE_AVOID_DELETE_EXPIRED)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If &#x27;expire&#x27; action is paused, for whatever reason, then don&#x27;t expire any key.</span></span><br><span class="line"><span class="comment">     * Typically, at the end of the pause we will properly expire the key OR we</span></span><br><span class="line"><span class="comment">     * will have failed over and the new primary will send us the expire. */</span></span><br><span class="line">    <span class="comment">/*   Returns bitmask of paused actions </span></span><br><span class="line"><span class="comment">     *   </span></span><br><span class="line"><span class="comment">     *   uint32_t isPausedActionsWithUpdate(uint32_t actions_bitmask) &#123;</span></span><br><span class="line"><span class="comment">     *      if (!(server.paused_actions &amp; actions_bitmask)) return 0;</span></span><br><span class="line"><span class="comment">     *      updatePausedActions();</span></span><br><span class="line"><span class="comment">     *      return (server.paused_actions &amp; actions_bitmask);</span></span><br><span class="line"><span class="comment">     *   &#125;</span></span><br><span class="line"><span class="comment">     *   </span></span><br><span class="line"><span class="comment">     *   如果过期操作被暂停，则不进行清除键操作，直接返回1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (isPausedActionsWithUpdate(PAUSE_ACTION_EXPIRE)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The key needs to be converted from static to heap before deleted */</span></span><br><span class="line">    <span class="comment">// 判断键是否在静态区域，如果是的话，需要将其在堆上进行分配</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * #define OBJ_STATIC_REFCOUNT (INT_MAX-1) -&gt; Object allocated in the stack.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> static_key = key-&gt;refcount == OBJ_STATIC_REFCOUNT;</span><br><span class="line">    <span class="keyword">if</span> (static_key) &#123;</span><br><span class="line">        <span class="comment">//这样做的原因是静态的对象不能被删除</span></span><br><span class="line">        key = createStringObject(key-&gt;ptr, sdslen(key-&gt;ptr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Delete the key */</span></span><br><span class="line">    deleteExpiredKeyAndPropagate(db,key);</span><br><span class="line">    <span class="keyword">if</span> (static_key) &#123;</span><br><span class="line">        decrRefCount(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>-&gt; setCommand -&gt; setGenericCommand -&gt; getGenericCommand<br>-&gt; lookupKeyReadOrReply -&gt; lookupKeyRead -&gt; lookupKeyReadWithFlags<br>-&gt; lookupKey -&gt; expireIfNeeded -&gt; deleteExpiredKeyAndPropagate:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete the specified expired key and propagate expire. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteExpiredKeyAndPropagate</span><span class="params">(redisDb *db, robj *keyobj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mstime_t</span> expire_latency;</span><br><span class="line">    <span class="comment">// 开始记录删除键的监视</span></span><br><span class="line">    latencyStartMonitor(expire_latency);</span><br><span class="line">    <span class="comment">// 用于删除指定的键</span></span><br><span class="line">    dbGenericDelete(db,keyobj,server.lazyfree_lazy_expire,DB_FLAG_KEY_EXPIRED);</span><br><span class="line">    <span class="comment">// 结束记录删除键的监视</span></span><br><span class="line">    latencyEndMonitor(expire_latency);</span><br><span class="line">    <span class="comment">// 将删除键的延迟记录到样本之中</span></span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">&quot;expire-del&quot;</span>,expire_latency);</span><br><span class="line">    <span class="comment">// 通知键过期事件</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EXPIRED,<span class="string">&quot;expired&quot;</span>,keyobj,db-&gt;id);</span><br><span class="line">    <span class="comment">// 传递一个键修改信号</span></span><br><span class="line">    signalModifiedKey(<span class="literal">NULL</span>, db, keyobj);</span><br><span class="line">    <span class="comment">// 传播删除事件，如果是主数据库会将删除操作传播至从数据库</span></span><br><span class="line">    propagateDeletion(db,keyobj,server.lazyfree_lazy_expire);</span><br><span class="line">    <span class="comment">// 增加服务的过期键统计</span></span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>-&gt; setCommand -&gt; setGenericCommand -&gt; getGenericCommand<br>-&gt; lookupKeyReadOrReply -&gt; lookupKeyRead -&gt; lookupKeyReadWithFlags<br>-&gt; lookupKey -&gt; expireIfNeeded -&gt; deleteExpiredKeyAndPropagate -&gt; dbGenericDelete:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Helper for sync and async delete. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbGenericDelete</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> async, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    dictEntry **plink;</span><br><span class="line">    <span class="keyword">int</span> table;</span><br><span class="line">    <span class="comment">// 从字典中找到对应的字典条目</span></span><br><span class="line">    <span class="comment">// 如果找到对应的字段条目，会调起dictPauseRehashing(d);暂停rehash操作</span></span><br><span class="line">    dictEntry *de = dictTwoPhaseUnlinkFind(db-&gt;dict,key-&gt;ptr,&amp;plink,&amp;table);</span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        <span class="comment">// 获取字典条目的值</span></span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line">        <span class="comment">/* RM_StringDMA may call dbUnshareStringValue which may free val, so we</span></span><br><span class="line"><span class="comment">         * need to incr to retain val */</span></span><br><span class="line">        <span class="comment">// 增加对值的引用数</span></span><br><span class="line">        <span class="comment">// RM_StringDMA可能会调用dbUnshareStringValue，这可能会导致值对象被释放。通过提前增加引用计数，可以确保在执行后续操作时，值对象不会被提前释放。</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> </span></span><br><span class="line">        incrRefCount(val);</span><br><span class="line">        <span class="comment">/* Tells the module that the key has been unlinked from the database. */</span></span><br><span class="line">        <span class="comment">// 通知模块该键已经从数据库中解除链接</span></span><br><span class="line">        moduleNotifyKeyUnlink(key,val,db-&gt;id,flags);</span><br><span class="line">        <span class="comment">/* We want to try to unblock any module clients or clients using a blocking XREADGROUP */</span></span><br><span class="line">        <span class="comment">// 将被删除的键标记为准备好被删除</span></span><br><span class="line">        signalDeletedKeyAsReady(db,key,val-&gt;type);</span><br><span class="line">        <span class="comment">/* We should call decr before freeObjAsync. If not, the refcount may be</span></span><br><span class="line"><span class="comment">         * greater than 1, so freeObjAsync doesn&#x27;t work */</span></span><br><span class="line">        <span class="comment">// 为了释放对象的freeObjAsync正常工作，我们需要减少值对象的引用计数</span></span><br><span class="line">        decrRefCount(val);</span><br><span class="line">        <span class="comment">// 如果要异步删除，就调用freeObjAsync函数异步释放键对象和值对象，并将字典条目的值设为NULL。</span></span><br><span class="line">        <span class="keyword">if</span> (async) &#123;</span><br><span class="line">            <span class="comment">/* Because of dbUnshareStringValue, the val in de may change. */</span></span><br><span class="line">            freeObjAsync(key, dictGetVal(de), db-&gt;id);</span><br><span class="line">            dictSetVal(db-&gt;dict, de, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果启用了集群模式，就调用slotToKeyDelEntry函数处理集群的槽位信息。</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 在Redis集群中，键槽（Hash Slot）是一种将所有的键分配到不同节点的方法。</span></span><br><span class="line"><span class="comment">         * 为了在集群中平衡存储和查询负载，Redis将所有的键分配到16384个键槽中。每一个键槽负责存储一部分键，</span></span><br><span class="line"><span class="comment">         * 并且由集群中的一个节点负责管理。当需要存储或查询一个键时，Redis会根据键的名称计算出它应该在哪个键槽中，</span></span><br><span class="line"><span class="comment">         * 然后找到负责这个键槽的节点，将操作发送到这个节点上。这种设计使得Redis可以在多个节点之间平衡负载，</span></span><br><span class="line"><span class="comment">         * 提高集群的存储容量和处理能力。当集群需要扩容或缩容时，Redis可以通过重新分配键槽来实现，而不需要移动所有的键。</span></span><br><span class="line"><span class="comment">         * 总的来说，键槽在Redis集群中的作用是将所有的键分配到不同的节点，使得集群可以平衡负载，提高存储容量和处理能力。</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * Redis选择使用键槽（Hash Slot）的方式做负载均衡主要是基于以下考虑：</span></span><br><span class="line"><span class="comment">         * 平衡存储和查询负载：通过将所有的键分配到16384个键槽中，并将键槽均匀地分配到各个节点，可以确保每个节点负责处理大约相等数量的键，从而在各个节点之间平衡存储和查询负载。</span></span><br><span class="line"><span class="comment">         * 支持动态扩展和收缩：当集群需要增加或减少节点时，可以通过重新分配键槽来实现。只需要移动一部分键槽及其对应的键，而不需要重新分配所有的键，这样可以减少数据迁移的开销。</span></span><br><span class="line"><span class="comment">         * 提高查询效率：当需要查询一个键时，可以直接计算出这个键在哪个键槽中，然后找到负责这个键槽的节点，直接发送请求到该节点，而不需要在所有节点中查找。这样可以提高查询效率，减少网络通信的开销。</span></span><br><span class="line"><span class="comment">         * 简化复制和故障恢复：每个节点只需要复制负责的键槽的数据，当节点发生故障时，只需要恢复这部分键槽的数据，这样可以简化复制和故障恢复的过程，提高系统的可用性。</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 因此，通过键槽的方式做负载均衡，可以使Redis集群在存储容量、处理能力、扩展性、查询效率和可用性等方面都有较好的性能。</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDelEntry(de, db);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Deleting an entry from the expires dict will not free the sds of</span></span><br><span class="line"><span class="comment">        * the key, because it is shared with the main dictionary. */</span></span><br><span class="line">        <span class="comment">// 如果过期字典的大小大于0，就从过期字典中删除这个键。</span></span><br><span class="line">        <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr);</span><br><span class="line">        <span class="comment">// dictTwoPhaseUnlinkFree释放数据字典的字典条目和键对象</span></span><br><span class="line">        dictTwoPhaseUnlinkFree(db-&gt;dict,de,plink,table);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>-&gt; setCommand -&gt; setGenericCommand -&gt; getGenericCommand<br>-&gt; lookupKeyReadOrReply -&gt; lookupKeyRead -&gt; lookupKeyReadWithFlags<br>-&gt; lookupKey -&gt; expireIfNeeded -&gt; deleteExpiredKeyAndPropagate -&gt; dbGenericDelete<br>-&gt; moduleNotifyKeyUnlink :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 后续研究下如何进行事件监听</span></span><br><span class="line"><span class="comment">/* When a key is deleted (in dbAsyncDelete/dbSyncDelete/setKey), it</span></span><br><span class="line"><span class="comment">*  will be called to tell the module which key is about to be released. */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当一个键被删除时（通过dbAsyncDelete/dbSyncDelete/setKey），这个函数将被调用以通知模块哪个键即将被释放。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moduleNotifyKeyUnlink</span><span class="params">(robj *key, robj *val, <span class="keyword">int</span> dbid, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 禁用延迟过期</span></span><br><span class="line">    <span class="comment">/* 增加延迟过期禁用计数 */</span></span><br><span class="line">    server.lazy_expire_disabled++;</span><br><span class="line">    <span class="comment">// 根据不同的操作标识设置子事件</span></span><br><span class="line">    <span class="keyword">int</span> subevent = REDISMODULE_SUBEVENT_KEY_DELETED;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; DB_FLAG_KEY_EXPIRED) &#123;</span><br><span class="line">        subevent = REDISMODULE_SUBEVENT_KEY_EXPIRED;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; DB_FLAG_KEY_EVICTED) &#123;</span><br><span class="line">        subevent = REDISMODULE_SUBEVENT_KEY_EVICTED;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; DB_FLAG_KEY_OVERWRITE) &#123;</span><br><span class="line">        subevent = REDISMODULE_SUBEVENT_KEY_OVERWRITTEN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建键信息</span></span><br><span class="line">    KeyInfo info = &#123;dbid, key, val, REDISMODULE_READ&#125;;</span><br><span class="line">    <span class="comment">// 触发模块事件，相关的可以看下对于模块事件的订阅 RM_SubscribeToServerEvent</span></span><br><span class="line">    <span class="comment">// RM_SubscribeToServerEvent是Redis模块API中的一个函数，用于让模块订阅特定的服务器事件。</span></span><br><span class="line">    <span class="comment">// 当这些事件发生时，比如键的删除、过期或者被重新命名等，Redis会调用模块注册的回调函数，以通知模块这些事件的发生。</span></span><br><span class="line">    moduleFireServerEvent(REDISMODULE_EVENT_KEY, subevent, &amp;info);</span><br><span class="line">    <span class="comment">// 如果值是模块对象</span></span><br><span class="line">    <span class="keyword">if</span> (val-&gt;type == OBJ_MODULE) &#123;</span><br><span class="line">        moduleValue *mv = val-&gt;ptr;</span><br><span class="line">        moduleType *mt = mv-&gt;type;</span><br><span class="line">        <span class="comment">/* We prefer to use the enhanced version. */</span></span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> </span></span><br><span class="line">        <span class="keyword">if</span> (mt-&gt;unlink2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            RedisModuleKeyOptCtx ctx = &#123;key, <span class="literal">NULL</span>, dbid, <span class="number">-1</span>&#125;;</span><br><span class="line">            mt-&gt;unlink2(&amp;ctx,mv-&gt;value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mt-&gt;unlink != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mt-&gt;unlink(key,mv-&gt;value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 减少延迟过期禁用计数 */</span></span><br><span class="line">    server.lazy_expire_disabled--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-&gt; setCommand -&gt; setGenericCommand -&gt; getGenericCommand<br>-&gt; lookupKeyReadOrReply -&gt; lookupKeyRead -&gt; lookupKeyReadWithFlags<br>-&gt; lookupKey -&gt; expireIfNeeded -&gt; deleteExpiredKeyAndPropagate -&gt; dbGenericDelete<br>-&gt; signalKeyAsReadyLogic:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* If the specified key has clients blocked waiting for list pushes, this</span></span><br><span class="line"><span class="comment"> * function will put the key reference into the server.ready_keys list.</span></span><br><span class="line"><span class="comment"> * Note that db-&gt;ready_keys is a hash table that allows us to avoid putting</span></span><br><span class="line"><span class="comment"> * the same key again and again in the list in case of multiple pushes</span></span><br><span class="line"><span class="comment"> * made by a script or in the context of MULTI/EXEC.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The list will be finally processed by handleClientsBlockedOnKeys() */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果指定的键有客户端阻塞等待列表推送，此函数将把键引用放入server.ready_keys列表。</span></span><br><span class="line"><span class="comment"> * 注意，db-&gt;ready_keys是一个哈希表，可以避免在脚本或MULTI/EXEC上下文中进行多次推送时，</span></span><br><span class="line"><span class="comment"> * 将同一个键反复放入列表中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 最后，该列表将由handleClientsBlockedOnKeys()处理。 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">signalKeyAsReadyLogic</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> type, <span class="keyword">int</span> deleted)</span> </span>&#123;</span><br><span class="line">    readyList *rl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Quick returns. */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据值类型获取阻塞类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> btype = getBlockedTypeByType(type);</span><br><span class="line">    <span class="comment">// 如果获取到的是BLOCKED_NONE类型，证明类型不支持阻塞，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (btype == BLOCKED_NONE) &#123;</span><br><span class="line">        <span class="comment">/* The type can never block. */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!server.blocked_clients_by_type[btype] &amp;&amp;</span><br><span class="line">        !server.blocked_clients_by_type[BLOCKED_MODULE]) &#123;</span><br><span class="line">        <span class="comment">/* No clients block on this type. Note: Blocked modules are represented</span></span><br><span class="line"><span class="comment">         * by BLOCKED_MODULE, even if the intention is to wake up by normal</span></span><br><span class="line"><span class="comment">         * types (list, zset, stream), so we need to check that there are no</span></span><br><span class="line"><span class="comment">         * blocked modules before we do a quick return here. */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * <span class="doctag">TODO:</span>//</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (deleted) &#123;</span><br><span class="line">        <span class="comment">/* Key deleted and no clients blocking for this key? No need to queue it. */</span></span><br><span class="line">        <span class="comment">/*键被删除但是没有客户在等待这个键，则直接返回，无需进入队列*/</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当一个键被删除或不存在时，Redis会查找blocking_keys_unblock_on_nokey字典，</span></span><br><span class="line"><span class="comment">         * 如果找到了相应的键，那么就会立即解除对应客户端的阻塞状态。</span></span><br><span class="line"><span class="comment">         * blocking_keys_unblock_on_nokey字典主要用于存储那些在键不存在时需要解除阻塞的键，</span></span><br><span class="line"><span class="comment">         * 它是Redis处理客户端阻塞逻辑的一部分。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (dictFind(db-&gt;blocking_keys_unblock_on_nokey,key) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">/* Note: if we made it here it means the key is also present in db-&gt;blocking_keys */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* No clients blocking for this key? No need to queue it. */</span></span><br><span class="line">        <span class="keyword">if</span> (dictFind(db-&gt;blocking_keys,key) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dictEntry *de, *existing;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将key放入到ready_keys中，如果已存在的key，函数返回空，对应的字典条目会通过existing返回，如果不存在则通过函数返回对应条目。</span></span><br><span class="line"><span class="comment">     * 这里要把key放到db-&gt;ready_keys(dict类型)中而不是直接放到server.ready_keys(list类型)中主要是为了避免多次添加到list中，</span></span><br><span class="line"><span class="comment">     * 对于已经添加过的则无需再处理</span></span><br><span class="line"><span class="comment">     * /</span></span><br><span class="line"><span class="comment">    de = dictAddRaw(db-&gt;ready_keys, key, &amp;existing);</span></span><br><span class="line"><span class="comment">    if (de) &#123;</span></span><br><span class="line"><span class="comment">        /* We add the key in the db-&gt;ready_keys dictionary in order</span></span><br><span class="line"><span class="comment">         * to avoid adding it multiple times into a list with a simple O(1)</span></span><br><span class="line"><span class="comment">         * check. */</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 增加key的引用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        incrRefCount(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 对应的key如果已经存在于ready_keys则直接返回</span></span><br><span class="line">        <span class="comment">/* Key was already signaled? No need to queue it again. */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ok, we need to queue this key into server.ready_keys. */</span></span><br><span class="line">    rl = zmalloc(<span class="keyword">sizeof</span>(*rl));</span><br><span class="line">    rl-&gt;key = key;</span><br><span class="line">    rl-&gt;db = db;</span><br><span class="line">    incrRefCount(key);</span><br><span class="line">    listAddNodeTail(server.ready_keys,rl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>-&gt; setCommand -&gt; setGenericCommand -&gt; getGenericCommand<br>-&gt; lookupKeyReadOrReply -&gt; lookupKeyRead -&gt; lookupKeyReadWithFlags<br>-&gt; lookupKey -&gt; expireIfNeeded -&gt; deleteExpiredKeyAndPropagate -&gt; dbGenericDelete<br>-&gt; freeObjAsync:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Free an object, if the object is huge enough, free it in async way. */</span></span><br><span class="line"><span class="comment">/* 释放对象 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeObjAsync</span><span class="params">(robj *key, robj *obj, <span class="keyword">int</span> dbid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 计算释放这个对象需要的工作量 */</span></span><br><span class="line">    <span class="keyword">size_t</span> free_effort = lazyfreeGetFreeEffort(key,obj,dbid);</span><br><span class="line">    <span class="comment">/* Note that if the object is shared, to reclaim it now it is not</span></span><br><span class="line"><span class="comment">     * possible. This rarely happens, however sometimes the implementation</span></span><br><span class="line"><span class="comment">     * of parts of the Redis core may call incrRefCount() to protect</span></span><br><span class="line"><span class="comment">     * objects, and then call dbDelete(). */</span></span><br><span class="line">    <span class="comment">/* 如果对象是共享的，那么现在就不能回收它。有时Redis核心的部分实现可能会调用incrRefCount()来保护对象，</span></span><br><span class="line"><span class="comment">     * 然后调用dbDelete()。如果释放工作量大于预设的阈值LAZYFREE_THRESHOLD，</span></span><br><span class="line"><span class="comment">     * 并且对象的引用计数为1（即没有其他地方再引用这个对象）*/</span></span><br><span class="line">    <span class="keyword">if</span> (free_effort &gt; LAZYFREE_THRESHOLD &amp;&amp; obj-&gt;refcount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// lazyfree_objects原子+1，表示有一个对象需要懒惰释放</span></span><br><span class="line">        atomicIncr(lazyfree_objects,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 创建一个懒惰释放的作业</span></span><br><span class="line">        bioCreateLazyFreeJob(lazyfreeFreeObject,<span class="number">1</span>,obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将对象的引用数-1</span></span><br><span class="line">        decrRefCount(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>-&gt; setCommand -&gt; setGenericCommand -&gt; getGenericCommand<br>-&gt; lookupKeyReadOrReply -&gt; lookupKeyRead -&gt; lookupKeyReadWithFlags<br>-&gt; lookupKey -&gt; expireIfNeeded -&gt; deleteExpiredKeyAndPropagate -&gt; dbGenericDelete<br>-&gt; freeObjAsync -&gt; bioCreateLazyFreeJob:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* free_fn：释放函数指针，arg_count：参数数量。后面可以跟随arg_count个参数，它们是释放函数需要的参数。 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bioCreateLazyFreeJob</span><span class="params">(lazy_free_fn free_fn, <span class="keyword">int</span> arg_count, ...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*可变参数列表*/</span></span><br><span class="line">    va_list valist;</span><br><span class="line">    <span class="comment">/* Allocate memory for the job structure and all required</span></span><br><span class="line"><span class="comment">     * arguments */</span></span><br><span class="line">    <span class="comment">/* 为任务结构和所有必需的参数分配内存。每个任务结构后面跟随arg_count个void指针大小的空间，用于存放释放函数的参数。 */</span></span><br><span class="line">    bio_job *job = zmalloc(<span class="keyword">sizeof</span>(*job) + <span class="keyword">sizeof</span>(<span class="keyword">void</span> *) * (arg_count));</span><br><span class="line">    <span class="comment">/* 设置任务的释放函数指针 */</span></span><br><span class="line">    job-&gt;free_args.free_fn = free_fn;</span><br><span class="line">    <span class="comment">/* 初始化可变参数列表 */</span></span><br><span class="line">    va_start(valist, arg_count);</span><br><span class="line">    <span class="comment">/* 从可变参数列表中取出arg_count个参数，存放到任务对象的free_args中 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arg_count; i++) &#123;</span><br><span class="line">        job-&gt;free_args.free_args[i] = va_arg(valist, <span class="keyword">void</span> *);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 结束使用可变参数列表 */</span></span><br><span class="line">    va_end(valist);</span><br><span class="line">    <span class="comment">/* 提交这个任务到后台I/O系统，让它在后台线程中执行。BIO_LAZY_FREE是任务类型的标识符，表示这是一个延迟释放任务。 */</span></span><br><span class="line">    <span class="comment">// TODO：为什么是BIO</span></span><br><span class="line">    bioSubmitJob(BIO_LAZY_FREE, job);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>-&gt; setCommand -&gt; setGenericCommand -&gt; getGenericCommand<br>-&gt; lookupKeyReadOrReply -&gt; lookupKeyRead -&gt; lookupKeyReadWithFlags<br>-&gt; lookupKey -&gt; expireIfNeeded -&gt; deleteExpiredKeyAndPropagate -&gt; dbGenericDelete<br>-&gt; dictDelete -&gt; dictGenericDelete:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Search and remove an element. This is a helper function for</span></span><br><span class="line"><span class="comment"> * dictDelete() and dictUnlink(), please check the top comment</span></span><br><span class="line"><span class="comment"> * of those functions. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> dictEntry *<span class="title">dictGenericDelete</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> nofree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> h, idx;</span><br><span class="line">    dictEntry *he, *prevHe;</span><br><span class="line">    <span class="keyword">int</span> table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dict is empty */</span></span><br><span class="line">    <span class="comment">// 字典为空直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 如果子弹处于rehash的状态则进行1次hash</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    <span class="comment">// 计算出key的hash值</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        <span class="comment">// 计算hash值对应的桶下标</span></span><br><span class="line">        idx = h &amp; DICTHT_SIZE_MASK(d-&gt;ht_size_exp[table]);</span><br><span class="line">        <span class="comment">// 获取对应桶下的第一个字典条目</span></span><br><span class="line">        he = d-&gt;ht_table[table][idx];</span><br><span class="line">        <span class="comment">// 声明用于标记上一个字典条目的变量</span></span><br><span class="line">        prevHe = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="comment">// 获取字典条目的key</span></span><br><span class="line">            <span class="keyword">void</span> *he_key = dictGetKey(he);</span><br><span class="line">            <span class="comment">// 判断是否为同一个key</span></span><br><span class="line">            <span class="keyword">if</span> (key == he_key || dictCompareKeys(d, key, he_key)) &#123;</span><br><span class="line">                <span class="comment">/* Unlink the element from the list */</span></span><br><span class="line">                <span class="comment">// 将he从链表中断开</span></span><br><span class="line">                <span class="keyword">if</span> (prevHe)</span><br><span class="line">                    <span class="comment">// 如果前面还有he，则把前面的he和后面的he进行连接</span></span><br><span class="line">                    dictSetNext(prevHe, dictGetNext(he));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 如果he为链表的第一个数据，则直接把他的下一个he放在ht_table[table][idx]位置上，即第一个位置</span></span><br><span class="line">                    d-&gt;ht_table[table][idx] = dictGetNext(he);</span><br><span class="line">                <span class="comment">// 如果nofree!=0释放he</span></span><br><span class="line">                <span class="keyword">if</span> (!nofree) &#123;</span><br><span class="line">                    <span class="comment">// 释放he</span></span><br><span class="line">                    dictFreeUnlinkedEntry(d, he);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// table中的已有的数据条目-1</span></span><br><span class="line">                d-&gt;ht_used[table]--;</span><br><span class="line">                <span class="keyword">return</span> he;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将上一个he设置成当前he</span></span><br><span class="line">            prevHe = he;</span><br><span class="line">            <span class="comment">// 将当前he设置成下一个he</span></span><br><span class="line">            he = dictGetNext(he);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* not found */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>-&gt; setCommand -&gt; setGenericCommand -&gt; getGenericCommand<br>-&gt; lookupKeyReadOrReply -&gt; lookupKeyRead -&gt; lookupKeyReadWithFlags<br>-&gt; lookupKey -&gt; expireIfNeeded -&gt; deleteExpiredKeyAndPropagate -&gt; dbGenericDelete<br>-&gt; dictDelete -&gt; dictGenericDelete -&gt; dictFreeUnlinkedEntry:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在调用dictUnlink()之后，你需要调用此函数来真正释放条目。</span></span><br><span class="line"><span class="comment"> * 使用&#x27;he&#x27; = NULL调用这个函数是安全的。 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictFreeUnlinkedEntry</span><span class="params">(dict *d, dictEntry *he)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 如果传入的条目为空，直接返回 */</span></span><br><span class="line">    <span class="keyword">if</span> (he == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* 释放条目中的键 */</span></span><br><span class="line">    dictFreeKey(d, he);</span><br><span class="line">    <span class="comment">/* 释放条目中的值 */</span></span><br><span class="line">    dictFreeVal(d, he);</span><br><span class="line">    <span class="comment">/* 如果条目不是键，则释放解码后的指针 */</span></span><br><span class="line">    <span class="keyword">if</span> (!entryIsKey(he)) zfree(decodeMaskedPtr(he));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-&gt; setCommand -&gt; setGenericCommand -&gt; setKey:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* High level Set operation. This function can be used in order to set</span></span><br><span class="line"><span class="comment"> * a key, whatever it was existing or not, to a new object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1) The ref count of the value object is incremented.</span></span><br><span class="line"><span class="comment"> * 2) clients WATCHing for the destination key notified.</span></span><br><span class="line"><span class="comment"> * 3) The expire time of the key is reset (the key is made persistent),</span></span><br><span class="line"><span class="comment"> *    unless &#x27;SETKEY_KEEPTTL&#x27; is enabled in flags.</span></span><br><span class="line"><span class="comment"> * 4) The key lookup can take place outside this interface outcome will be</span></span><br><span class="line"><span class="comment"> *    delivered with &#x27;SETKEY_ALREADY_EXIST&#x27; or &#x27;SETKEY_DOESNT_EXIST&#x27;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * All the new keys in the database should be created via this interface.</span></span><br><span class="line"><span class="comment"> * The client &#x27;c&#x27; argument may be set to NULL if the operation is performed</span></span><br><span class="line"><span class="comment"> * in a context where there is no clear client performing the operation. */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 此函数可用于设置为键，无论该键是否已存在。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1) 值对象的引用计数增加。</span></span><br><span class="line"><span class="comment"> * 2) 正在监视目标键的客户端会被通知。</span></span><br><span class="line"><span class="comment"> * 3) 除非在标志中启用了&#x27;SETKEY_KEEPTTL&#x27;，否则键的到期时间会被重置（键会变为持久的）。</span></span><br><span class="line"><span class="comment"> * 4) 键查找可以在此接口外部进行，其结果将以&#x27;SETKEY_ALREADY_EXIST&#x27;或&#x27;SETKEY_DOESNT_EXIST&#x27;形式提供。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 数据库中的所有新键都应通过此接口创建。</span></span><br><span class="line"><span class="comment"> * 如果操作是在没有明确执行操作的客户端的上下文中执行的，则客户端&#x27;c&#x27;参数可以设置为NULL。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setKey</span><span class="params">(client *c, redisDb *db, robj *key, robj *val, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> keyfound = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 根据flag确认key是否已存在</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; SETKEY_ALREADY_EXIST)</span><br><span class="line">        keyfound = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; SETKEY_ADD_OR_UPDATE)</span><br><span class="line">        keyfound = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!(flags &amp; SETKEY_DOESNT_EXIST))</span><br><span class="line">        keyfound = (lookupKeyWrite(db,key) != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!keyfound) &#123;</span><br><span class="line">        <span class="comment">// // 如果键不存在则将键新增至数据库</span></span><br><span class="line">        dbAdd(db,key,val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyfound&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 插入键，如果已存在则更细</span></span><br><span class="line">        dbAddInternal(db,key,val,<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果键存在，则在数据库中设置键和值 </span></span><br><span class="line">        dbSetValue(db,key,val,<span class="number">1</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 增加值对象的引用计数 */</span></span><br><span class="line">    incrRefCount(val);</span><br><span class="line">    <span class="comment">/* 除非在标志中启用了&#x27;SETKEY_KEEPTTL&#x27;，否则移除键的过期时间 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; SETKEY_KEEPTTL)) removeExpire(db,key);</span><br><span class="line">    <span class="comment">/* 除非在标志中启用了&#x27;SETKEY_NO_SIGNAL&#x27;，否则发送修改键的信号 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; SETKEY_NO_SIGNAL)) signalModifiedKey(c,db,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-&gt; setCommand -&gt; setGenericCommand -&gt; setExpire:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Set an expire to the specified key. If the expire is set in the context</span></span><br><span class="line"><span class="comment"> * of an user calling a command &#x27;c&#x27; is the client, otherwise &#x27;c&#x27; is set</span></span><br><span class="line"><span class="comment"> * to NULL. The &#x27;when&#x27; parameter is the absolute unix time in milliseconds</span></span><br><span class="line"><span class="comment"> * after which the key will no longer be considered valid. */</span></span><br><span class="line"><span class="comment">/* 为key设置过期时间 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setExpire</span><span class="params">(client *c, redisDb *db, robj *key, <span class="keyword">long</span> <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    dictEntry *kde, *de;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reuse the sds from the main dict in the expire dict */</span></span><br><span class="line">    <span class="comment">/* 确保key在字典中存在 */</span></span><br><span class="line">    kde = dictFind(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,key,kde != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 通过key在过期字典中找到对应的字典条目 */</span></span><br><span class="line">    de = dictAddOrFind(db-&gt;expires,dictGetKey(kde));</span><br><span class="line">    <span class="comment">/* 设置过期时间 */</span></span><br><span class="line">    dictSetSignedIntegerVal(de,when);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> writable_slave = server.masterhost &amp;&amp; server.repl_slave_ro == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (c &amp;&amp; writable_slave &amp;&amp; !(c-&gt;flags &amp; CLIENT_MASTER))</span><br><span class="line">        <span class="comment">// 如果客户端存在并且当前实例为可写的从服务器，并且客户端不是主服务器</span></span><br><span class="line">        <span class="comment">// 则记住带有过期时间的从服务器键</span></span><br><span class="line">        rememberSlaveKeyWithExpire(db,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>nytech
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://nytech3.github.io/2023/09/11/redis/redis_set/" title="源码阅读(二)-Redis中的SET命令">https://nytech3.github.io/2023/09/11/redis/redis_set/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/c/" rel="tag"># c</a>
              <a href="/tags/redis/" rel="tag"># redis</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/09/10/redis/redis_sds/" rel="prev" title="源码阅读(一)-Redis中的SDS数据结构">
      <i class="fa fa-chevron-left"></i> 源码阅读(一)-Redis中的SDS数据结构
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/09/16/redis/redis_script/" rel="next" title="源码阅读(十一)-Redis中的script、eval">
      源码阅读(十一)-Redis中的script、eval <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">工作流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Set-json"><span class="nav-number">2.1.</span> <span class="nav-text">Set json</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%BB%84-group"><span class="nav-number">2.1.1.</span> <span class="nav-text">分组(group)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96key%E5%87%BD%E6%95%B0-get-keys-function"><span class="nav-number">2.1.2.</span> <span class="nav-text">获取key函数(get_keys_function)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E5%88%86%E7%B1%BB-acl-categories"><span class="nav-number">2.1.3.</span> <span class="nav-text">权限分类(acl_categories)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#key-specs"><span class="nav-number">2.1.4.</span> <span class="nav-text">key_specs</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">2.2.</span> <span class="nav-text">代码分析</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="nytech"
      src="/images/author.jpg">
  <p class="site-author-name" itemprop="name">nytech</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">140</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/nytech3" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;nytech3" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nytech</span>
</div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"J6lBEIRqy1W5i6vcNgfWkL1P-gzGzoHsz","app_key":"tlzt00UvOikqxddgeJ59o1id","security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
