<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"nytech3.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="操作系统进程和线程一个单核CPU在同一时间内只能执行一个任务，但是在我们使用电脑时，可以同时打开多个软件，看起来多个软件就像是在同时运行一样，这是由于CPU会轮流调度多个进程，由于其调度的速度足够快，就让使用产生了很多软件在同时运行的错觉。对于操作系统而言，一个任务就代表一个进程，例如你有两个软件，qq和微信，打开一个qq，那么就启动了一个进程，打开两个qq就是启动了两个进程，如果打开两个qq加">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统_操作系统进程和线程">
<meta property="og:url" content="https://nytech3.github.io/2021/04/27/operationsystem/operation_system_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="nytech">
<meta property="og:description" content="操作系统进程和线程一个单核CPU在同一时间内只能执行一个任务，但是在我们使用电脑时，可以同时打开多个软件，看起来多个软件就像是在同时运行一样，这是由于CPU会轮流调度多个进程，由于其调度的速度足够快，就让使用产生了很多软件在同时运行的错觉。对于操作系统而言，一个任务就代表一个进程，例如你有两个软件，qq和微信，打开一个qq，那么就启动了一个进程，打开两个qq就是启动了两个进程，如果打开两个qq加">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-04-27T10:11:25.000Z">
<meta property="article:modified_time" content="2024-09-19T07:25:56.998Z">
<meta property="article:author" content="nytech">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://nytech3.github.io/2021/04/27/operationsystem/operation_system_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>操作系统_操作系统进程和线程 | nytech</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">nytech</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">24</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">3</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">140</span></a>

  </li>
        <li class="menu-item menu-item-following">

    <a href="/following/" rel="section"><i class="following fa-fw"></i>关注</a>

  </li>
        <li class="menu-item menu-item-tool">

    <a href="/tool/" rel="section"><i class="tool fa-fw"></i>工具</a>

  </li>
        <li class="menu-item menu-item-dailyguide">

    <a href="/dailyguide" rel="section"><i class="dailyguide fa-fw"></i>每日导读</a>

  </li>
        <li class="menu-item menu-item-book">

    <a href="/book" rel="section"><i class="book fa-fw"></i>书籍</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/nytech3" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nytech3.github.io/2021/04/27/operationsystem/operation_system_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/author.jpg">
      <meta itemprop="name" content="nytech">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nytech">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统_操作系统进程和线程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-27 18:11:25" itemprop="dateCreated datePublished" datetime="2021-04-27T18:11:25+08:00">2021-04-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          
            <span id="/2021/04/27/operationsystem/operation_system_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" class="post-meta-item leancloud_visitors" data-flag-title="操作系统_操作系统进程和线程" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <!-- ttoc -->
<h1 id="操作系统进程和线程"><a href="#操作系统进程和线程" class="headerlink" title="操作系统进程和线程"></a>操作系统进程和线程</h1><p>一个单核CPU在同一时间内只能执行一个任务，但是在我们使用电脑时，可以同时打开多个软件，看起来多个软件就像是在同时运行一样，这是由于CPU会轮流调度多个进程，由于其调度的速度足够快，就让使用产生了很多软件在同时运行的错觉。<br>对于操作系统而言，一个任务就代表一个进程，例如你有两个软件，qq和微信，打开一个qq，那么就启动了一个进程，打开两个qq就是启动了两个进程，如果打开两个qq加一个微信就是3个进程。<br>线程是最小的执行单位，一个进程可以拥有多个线程，由于每个进程至少都需要一个主线程，所以可以这么讲，一个进程至少拥有一个以上的线程。<br>同一程序可产生多个进程（一对多关系），以允许同时有多位用户运行同一程序，却不会相冲突。<br>一个进程中的多个线程可以被多个处理器并行执行。</p>
<span id="more"></span>


<h2 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h2><p>进程控制块（英语：Process Control Block，PCB）是操作系统核心中一种数据结构，主要表示进程状态。<br>虽各实际情况不尽相同，PCB通常记载行程之相关信息，包括：  </p>
<p>行程状态：可以是new、ready、running、waiting或blocked等。<br>程序计数器：接着要运行的指令地址。<br>CPU寄存器：如累加器、变址寄存器、堆栈指针以及一般用途寄存器、状况代码等，主要用途在于中断时暂时存储资料，以便稍后继续利用；其数量及类别因计算机体系结构有所差异。<br>CPU排班法：优先级、排班队列等指针以及其他参数。<br>存储器管理：如标签页表等。<br>会计信息：如CPU与实际时间之使用数量、时限、账号、工作或行程号码。<br>输入输出状态：配置行程使用I/O设备，如磁带机。  </p>
<h2 id="进程的状态转化"><a href="#进程的状态转化" class="headerlink" title="进程的状态转化"></a>进程的状态转化</h2><p>进程在运行过程中，进程的状态会发生改变。<br><a href="/images/operation_system_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B_01.png">operation_system_操作系统进程和线程_01</a><br>新建(new): 进程新建中。<br>运行(running): 进程占有CPU正在运行中。<br>等待(waiting): 等待事件完成，重新调起进入待执行队列。<br>就绪(ready): 等待CPU执行。<br>结束(terminated): 完成运行。<br>挂起就绪态：进程具备运行条件，但目前在外存中，只有它被对换到内存才能被调度执行。<br>挂起等待态：表明进程正在等待某一个事件发生且在外存中。  </p>
<p>转化流程:<br>新建态: 执行一个程序，创建一个进程,操作系统为该进程分配系统资源、初始化PCB。<br>新建态 -&gt; 就绪态: 程序完成进程创建之后，等待系统资源调度。<br>就绪态 -&gt; 运行态: 程序占有CPU,执行程序。<br>运行态 -&gt; 就绪态: 1.运行时间片到期 2.更高优先级的进程抢占CPU。<br>运行态 -&gt; 等待态: 1.等待使用资源 2.等待外设传输 3.等待人工干预<br>运行态 -&gt; 终止态: 1.程序执行完成 2.发生异常 3.被系统或者其他拥有终止权限的进程终结。<br>就绪态 -&gt; 终止态: 父进程终止子进程。<br>等待态 -&gt; 终止态：父进程终止子进程。<br>终止态: 操作系统会回收该进程拥有的系统资源、撤销PCB。</p>
<h2 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h2><p>进程间通信(IPC,Inter-Process Communication),指至少两个进程或者线程之间传输数据或者信号的一些技术或者方法</p>
<h3 id="匿名管道-pipe"><a href="#匿名管道-pipe" class="headerlink" title="匿名管道(pipe)"></a>匿名管道(pipe)</h3><pre><code>1. 管道是一种半双工通信，数据只能单向流动   
2. 匿名管道只能在父子进程之间使用  
匿名管道的实现大概如下:  
1. 父进程创建管道，得到两个文件描述符指向管道的两端
2. 父进程fork出子进程，子进程也有两个文件描述符指向同一管道
3. 子进程关闭fd[0],父进程关闭fd[1],即子进程关闭读通道，父进程关闭写通道(匿名管道只支持单向通信)。子进程可以往管道中写，父进程可以从管道中读。
</code></pre>
<p>示例代码：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pipeDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> result = pipe(fd);</span><br><span class="line">	<span class="keyword">if</span> (result == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		  C 库函数 void perror(const char *str) 把一个描述性错误消息输出到标准错误 stderr。首先输出字符串 str，后跟一个冒号，然后是一个空格。</span></span><br><span class="line"><span class="comment">		  详见 https://www.runoob.com/cprogramming/c-function-perror.html</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		perror(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">pid_t</span> id = fork();</span><br><span class="line">	<span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">//返回等于0的进程就是子进程</span></span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		close(fd[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">char</span> *child = <span class="string">&quot;i am child!&quot;</span>;</span><br><span class="line">		<span class="keyword">while</span> (i&lt;<span class="number">5</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			write(fd[<span class="number">1</span>], child, <span class="built_in">strlen</span>(child) + <span class="number">1</span>);</span><br><span class="line">			sleep(<span class="number">2</span>);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> (id &gt; <span class="number">0</span>)	&#123;</span><br><span class="line">		 <span class="comment">//返回大于0的进程就是父进程</span></span><br><span class="line">		close(fd[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">char</span> msg[<span class="number">100</span>];</span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (j &lt; <span class="number">5</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/*memset:作用是在一段内存块中填充某个给定的值，它对较大的结构体或数组进行清零操作的一种最快方法*/</span></span><br><span class="line">			<span class="built_in">memset</span>(msg,<span class="string">&#x27;\0&#x27;</span>,<span class="keyword">sizeof</span>(msg));</span><br><span class="line">			<span class="keyword">ssize_t</span> s = read(fd[<span class="number">0</span>],msg,<span class="keyword">sizeof</span>(msg));</span><br><span class="line">			<span class="keyword">if</span> (s&gt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				msg[s<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,msg);</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		perror(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pipeDemo(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="有名管道-named-pipe"><a href="#有名管道-named-pipe" class="headerlink" title="有名管道(named pipe)"></a>有名管道(named pipe)</h3><p>有名管道也是半双工通信，只能有一个单向的数据流与匿名管道的区别在于其可以给无亲缘关系的进程进行通信。</p>
<ol>
<li>每一个管道都有一个路径名，故其可以跨进程通信</li>
<li>匿名管道存在于内存，而有名管道存在于磁盘</li>
<li>有名管道有别于文件，文件数据被读取之后，数据仍然存在，但有名管道的数据被读取之后，数据就消失了。  </li>
</ol>
<p>在linux中 | 为管道，是两个进程之间的通信通道<br>例如：<code>cat test.txt | grep &#39;aaa&#39;</code><br>ls和grep由|分开，管道创建了程序之间的通信通道，将cat的输出作为输入传给grep  </p>
<p>由mkfifo创建出来的就是一个命名管道<br>例如：<code>mkfifo pipeTest</code><br>pipeTest就是一个命名管道。 </p>
<p>命名管道创建之后还能像文件一样进行访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  c git:(master) ✗ mkfifo pipeTest</span><br><span class="line">➜  c git:(master) ✗ ll pipeTest</span><br><span class="line">prw-r--r--  1 joeytsai  staff     0B  4 28 17:08 pipeTest</span><br></pre></td></tr></table></figure>

<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><ol>
<li>Linux内核提供的消息队列可以达到一个进程向另外一个进程发送消息的目的，并且消息队列可以根据消息中的类型字段进行消息分类。接收进程可以根据制定类型字段来接收消息，也可以直接不区分类型，直接获取队首消息。</li>
<li>消息队列的生存周期和共享内存一样，都是和内核的生命周期相同，在创建之后需要用户手动删除。</li>
</ol>
<h3 id="共享存储区"><a href="#共享存储区" class="headerlink" title="共享存储区"></a>共享存储区</h3><p>共享存储区即在内存中开辟一块所有进程共享的区块，将要进行通信的进程映射到共享存储区上，发送方和接收方一同使用这个共享区域。</p>
<h3 id="信号量通信"><a href="#信号量通信" class="headerlink" title="信号量通信"></a>信号量通信</h3><ol>
<li>信号量的使用可以解决多个线程访问同一块内存时产生的一系列问题，当进程获取到信号的时候进行P操作（将信号量-1），这时控制其他进程发现信号量小于等于0则不允许访问临界资源，新进来的进程进入阻塞状态，进入队列，当获取到信号的进程执行完想执行的操作之后就释放信号，执行V操作（将信号量+1），唤起下一个进程访问临界资源。这样就能控制同一时间只有一个进程访问共享资源。  </li>
<li>P和V是来源于两个荷兰语词汇，P—— passeren，中文译为”通过”；V—— vrijgeven，中文译为”释放”。  </li>
</ol>
<h3 id="信号通信（signal）"><a href="#信号通信（signal）" class="headerlink" title="信号通信（signal）"></a>信号通信（signal）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Traditional Signal Processing	</span><br><span class="line">A special signal action structure (sigaction) allows a process to associate an action with each type of signal that may be delivered to it. A process may choose to:	</span><br><span class="line"> 	∙		Ignore the signal (SIG_IGN)	</span><br><span class="line"> 	∙		Use the default action (SIG_DFL) 	</span><br><span class="line">The default signal action depends on which signal is being received. Most signals terminate the process, but a few are ignored by default. SIGSTOP and SIGTSTP suspend the process, while SIGCONT resumes it. 	</span><br><span class="line"> 	∙		Catch the signal, and execute a user-specified handler routine 	\</span><br><span class="line">When it&#39;s created, a process is given the default action for each signal. You can change the action for most signals by using the sigaction call. Some signals (such as SIGKILL and SIGSTOP), however, cannot be ignored or caught. 	</span><br><span class="line"></span><br><span class="line">The arrival of a signal interrupts a process at its current point of execution and transfers execution to a signal-handling routine. When the signal handler returns, the process resumes at its prior execution point. 	</span><br></pre></td></tr></table></figure>

<ol>
<li>SIGINT：ctrl+c 终止信号</li>
<li>SIGQUIT：ctrl+\ 终止信号</li>
<li>SIGTSTP:ctrl+z 暂停信号</li>
<li>SIGALRM：闹钟信号 收到此信号后定时结束，结束进程</li>
<li>SIGCHLD：子进程状态改变，父进程收到信号</li>
<li>SIGKILL：杀死信号<br>可用于优雅退出，当用户触发ctrl+c时，程序可先执行退出前的预处理，比如说进程需要要求某些线程一定要执行完才能退出，那么监听到信号之后，先等待执行完之后再退出。若是直接使用<code>kill -9 pid</code>会导致某些线程突然直接中断处理。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nctrl + c\n&quot;</span>);<span class="comment">//打印 ctrl </span></span><br><span class="line">    kill(getpid(),<span class="number">9</span>); <span class="comment">//9表示 SIGKILL 杀死信号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGINT,handler);<span class="comment">//定义自己的处理信号，当SIGINT信号发生时，调用 handler 函数处理</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="套接字通信"><a href="#套接字通信" class="headerlink" title="套接字通信"></a>套接字通信</h3><p>套接字( socket ) ： 套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</p>
<h2 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h2><p>Linux系统的多线程通信主要有以下几种:   </p>
<h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><p>包括互斥量，条件变量，读写锁   </p>
<h4 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h4><p>互斥量本质上是一把锁（互斥锁）。<br>在访问共享资源时对互斥量进行加锁,在访问结束之后释放互斥量。这时候只让持有互斥量的线程使用共享资源就可以实现共享资源被唯一使用了。<br>提供了以排他方式防止数据结构被并发修改的方法。      </p>
<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>互斥锁仅有加锁和释放锁两种<br>读写锁允许多个线程同时读共享数据，而对写数据是互斥的。<br>读写锁有三种状态读锁，写锁，不加锁。  </p>
<ol>
<li>当没有其他线程拥有写锁时，可以获取到其读锁。  </li>
<li>当没有其他线程拥有读锁或者写锁时，可以获取到其写锁。       <h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><a href="/images/operation_system_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B_02.png">operation_system_操作系统进程和线程_02</a><br>参考： <a target="_blank" rel="noopener" href="https://www.haroldrandom.me/post/ostp/condition-variables">https://www.haroldrandom.me/post/ostp/condition-variables</a>  </li>
</ol>
<p>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的使用是在互斥锁的保护下进行的，条件变量总是与互斥锁一同使用。互斥锁保护着条件变量，防止多个线程对条件变量产生竞争。<br>条件变量是多个线程之间可以通过它来告知某件事情已经完成，其他线程可以继续进行后续操作。而互斥量保护着条件变量不被其他线程同步访问。  </p>
<h3 id="信号量机制-Semaphore"><a href="#信号量机制-Semaphore" class="headerlink" title="信号量机制(Semaphore)"></a>信号量机制(Semaphore)</h3><h4 id="无名信号量-amp-命名线程信号量"><a href="#无名信号量-amp-命名线程信号量" class="headerlink" title="无名信号量 &amp; 命名线程信号量"></a>无名信号量 &amp; 命名线程信号量</h4><p>PV操作<br>有名信号量和无名信号量的差异在于创建和销毁的形式上，但是其他工作一样。</p>
<p>无名信号量只能存在于内存中，要求使用信号量的进程必须能访问信号量所在的这一块内存，所以无名信号量只能应用在同一进程内的线程之间（共享进程的内存），或者不同进程中已经映射相同内存内容到它们的地址空间中的线程（即信号量所在内存被通信的进程共享）。意思是说无名信号量只能通过共享内存访问。</p>
<p>相反，有名信号量可以通过名字访问，因此可以被任何知道它们名字的进程中的线程使用。</p>
<p>单个进程中使用 POSIX 信号量时，无名信号量更简单。多个进程间使用 POSIX 信号量时，有名信号量更简单。</p>
<h4 id="信号机制-Signal"><a href="#信号机制-Signal" class="headerlink" title="信号机制(Signal)"></a>信号机制(Signal)</h4><h5 id="进程信号机制和线程信号机制的区别"><a href="#进程信号机制和线程信号机制的区别" class="headerlink" title="进程信号机制和线程信号机制的区别"></a>进程信号机制和线程信号机制的区别</h5><ol>
<li>在多线程中处理信号和多进程处理信号中，多进程是异步处理的，多进程中信号的处理是先注册处理函数，当信号异步发生时，调用处理函数来处理信号。而多线程是同步的，多线程会使用一个线程去等待信号的到来，其他线程可以完全不被该信号打断。  </li>
<li>在多进程中，一些函数read、recv等调用时会被异步的信号给中断(interrupt)，因此我们必须对在这些函数在调用时因为信号而中断的情况进行处理。多线程中其他线程不受影响。</li>
</ol>
<p><a href="/images/operation_system_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B_02.png">operation_system_操作系统进程和线程_02</a>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Synchronously generated signals	</span><br><span class="line"></span><br><span class="line">Certain signals are synchronously generated in the sense that they are sent to a process as the direct result of an operation within a particular thread. The system is sending the process a signal because one of its threads tried to divide by zero (SIGFPE), touch forbidden memory in the wrong way (SIGSEGV), use a broken pipe (SIGPIPE), or do something else that triggered an exception. These signals are closely bound to the activities of a given thread, and it will be that thread, in its own context, that will handle the signal on behalf of the process as a whole. 	</span><br><span class="line"></span><br><span class="line">The other type of synchronously generated signal results from one thread in a process calling pthread_kill to send a signal to another thread in the same process. The calling thread explicitly names the target thread by specifying its thread handle, as well as the signal to be delivered to it. You cannot use pthread_kill to send signals to threads in other processes. 	</span><br><span class="line"></span><br><span class="line">Note that you shouldn&#39;t use pthread_kill in place of cancellation or condition variables. Because the Pthreads standard doesn&#39;t define any new signals with a thread-specific semantic, the pthread_kill function is limited to sending POSIX.1 and POSIX.1b signals. Trying to terminate (or direct the behavior of) a single thread using a traditional signal is like trying to comb your hair with a rake. It&#39;ll be difficult and you won&#39;t exactly get what you want. 	</span><br><span class="line"></span><br><span class="line">Asynchronously generated signals	</span><br><span class="line"></span><br><span class="line">Other signals are asynchronously generated in the sense that they cannot be easily pinned to a particular thread. The arrival of these signals is asynchronous to the activities of any and all threads within the process. They are typically job control signals≈SIGALRM, SIGHUP, SIGINT, and SIGKILL≈or the user-defined signals≈SIGUSR1 and SIGUSR2. They are sent to the process by a kill call and can be handled by almost any of its threads. (Because thread handles are unique only within a process, there&#39;s no way that a kill call≈or a pthread_kill call, for that matter≈can send a signal from one process to a thread in another process. As a result, all kill calls result in an asynchronously generated signal.) 	</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h3><ol>
<li>互斥: 资源处于非共享状态，即一次只有一个进程可以使用。如果另一进程申请该资源，那必须等待直到该资源被释放为止。</li>
<li>占有并等待: 一个进程至少应该占有一个资源，并等待另一资源，而另一资源被其他进程占有。</li>
<li>非抢占：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</li>
<li>循环等待：有一组等待进程{P0, P1,…, Pn}，P0等待的资源被 P1占有，P1等待的资源被P2 占有，……，Pn-1 等待的资源被Pn占有，Pn等待的资源被P0占有。</li>
</ol>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><h4 id="加锁顺序"><a href="#加锁顺序" class="headerlink" title="加锁顺序"></a>加锁顺序</h4><p>按顺序加锁是一种有效的死锁预防机制。但是这种方式需要开发者事先知道所有可能会用到的锁。</p>
<h4 id="加锁时限"><a href="#加锁时限" class="headerlink" title="加锁时限"></a>加锁时限</h4><p>给尝试获取锁的时候加一个超时时间，当在尝试获取锁的过程中超过了这个时限则视为该线程放弃对该锁的请求。若一个线程没有在给定的时间内获取到所有所需要的锁，则会回退并释放所有已经获得的锁，然后等待一段时间再次重试。在等待的时间内，使得其他线程有机会获取得到这些锁。</p>
<h4 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h4><p>死锁检测是一种更好的预防机制，每当一个线程得到了锁，都会在线程和锁相关的数据结构将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。  </p>
<p>当一个线程请求失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。  </p>
<p>参考资料:<br><a target="_blank" rel="noopener" href="https://www.javatpoint.com/os-process-states">Process States</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c1015f5ffa74">进程间通信IPC (InterProcess Communication)</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/violet_echo_0908/article/details/51201278">进程间8种通信方式详解</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/abc123lzf/article/details/101533778">Linux操作系统进程间通信方式：消息队列</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/electronic/p/10939769.html">Linux 进程间通信 信号（signal）</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/enjoymyselflzz/article/details/81603577">进程间通信之信号量</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_38121874/article/details/79468468">线程中的互斥量</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/lixiaogang_theanswer/article/details/85272668">Linux线程同步之读写锁</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34087301/article/details/88009172">POSIX 有名信号量与无名信号量</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/charlesblc/p/6143397.html">信号量与条件变量的区别</a><br><a target="_blank" rel="noopener" href="https://maxim.int.ru/bookshelf/PthreadsProgram/htm/r_40.html">hreads and Signals</a></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>nytech
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://nytech3.github.io/2021/04/27/operationsystem/operation_system_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" title="操作系统_操作系统进程和线程">https://nytech3.github.io/2021/04/27/operationsystem/operation_system_操作系统进程和线程/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/26/operationsystem/operation_system_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/" rel="prev" title="操作系统_操作系统进程和线程">
      <i class="fa fa-chevron-left"></i> 操作系统_操作系统进程和线程
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/28/jvm/JVM%E8%A7%A3%E9%87%8A%E5%99%A8%E5%92%8CJIT%E7%9A%84%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8/" rel="next" title="jvm-JVM解释器和JIT的即时编译器">
      jvm-JVM解释器和JIT的即时编译器 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">操作系统进程和线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="nav-number">1.1.</span> <span class="nav-text">进程控制块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8C%96"><span class="nav-number">1.2.</span> <span class="nav-text">进程的状态转化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">1.3.</span> <span class="nav-text">进程间的通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93-pipe"><span class="nav-number">1.3.1.</span> <span class="nav-text">匿名管道(pipe)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93-named-pipe"><span class="nav-number">1.3.2.</span> <span class="nav-text">有名管道(named pipe)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">1.3.3.</span> <span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E5%8C%BA"><span class="nav-number">1.3.4.</span> <span class="nav-text">共享存储区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%80%9A%E4%BF%A1"><span class="nav-number">1.3.5.</span> <span class="nav-text">信号量通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%80%9A%E4%BF%A1%EF%BC%88signal%EF%BC%89"><span class="nav-number">1.3.6.</span> <span class="nav-text">信号通信（signal）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1"><span class="nav-number">1.3.7.</span> <span class="nav-text">套接字通信</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">1.4.</span> <span class="nav-text">线程间的通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E6%9C%BA%E5%88%B6"><span class="nav-number">1.4.1.</span> <span class="nav-text">锁机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">互斥量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">读写锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">条件变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6-Semaphore"><span class="nav-number">1.4.2.</span> <span class="nav-text">信号量机制(Semaphore)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E5%90%8D%E4%BF%A1%E5%8F%B7%E9%87%8F-amp-%E5%91%BD%E5%90%8D%E7%BA%BF%E7%A8%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">无名信号量 &amp; 命名线程信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6-Signal"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">信号机制(Signal)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.2.2.1.</span> <span class="nav-text">进程信号机制和线程信号机制的区别</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">1.5.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.5.1.</span> <span class="nav-text">死锁产生的条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-number">1.5.2.</span> <span class="nav-text">避免死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E9%94%81%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">加锁顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E9%94%81%E6%97%B6%E9%99%90"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">加锁时限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">死锁检测</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="nytech"
      src="/images/author.jpg">
  <p class="site-author-name" itemprop="name">nytech</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">140</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/nytech3" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;nytech3" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nytech</span>
</div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"J6lBEIRqy1W5i6vcNgfWkL1P-gzGzoHsz","app_key":"tlzt00UvOikqxddgeJ59o1id","security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
